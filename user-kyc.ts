// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.32.1
// source: user-kyc.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "user";

export enum EmploymentType {
  NOT_USED_EMPLOYMENTTYPE = 0,
  FULL_TIME = 1,
  PART_TIME = 2,
  CONTRACT = 3,
  FREELANCE = 4,
  SELF_EMPLOYED = 5,
  INTERNSHIP = 6,
  UNRECOGNIZED = -1,
}

export function employmentTypeFromJSON(object: any): EmploymentType {
  switch (object) {
    case 0:
    case "NOT_USED_EMPLOYMENTTYPE":
      return EmploymentType.NOT_USED_EMPLOYMENTTYPE;
    case 1:
    case "FULL_TIME":
      return EmploymentType.FULL_TIME;
    case 2:
    case "PART_TIME":
      return EmploymentType.PART_TIME;
    case 3:
    case "CONTRACT":
      return EmploymentType.CONTRACT;
    case 4:
    case "FREELANCE":
      return EmploymentType.FREELANCE;
    case 5:
    case "SELF_EMPLOYED":
      return EmploymentType.SELF_EMPLOYED;
    case 6:
    case "INTERNSHIP":
      return EmploymentType.INTERNSHIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EmploymentType.UNRECOGNIZED;
  }
}

export function employmentTypeToJSON(object: EmploymentType): string {
  switch (object) {
    case EmploymentType.NOT_USED_EMPLOYMENTTYPE:
      return "NOT_USED_EMPLOYMENTTYPE";
    case EmploymentType.FULL_TIME:
      return "FULL_TIME";
    case EmploymentType.PART_TIME:
      return "PART_TIME";
    case EmploymentType.CONTRACT:
      return "CONTRACT";
    case EmploymentType.FREELANCE:
      return "FREELANCE";
    case EmploymentType.SELF_EMPLOYED:
      return "SELF_EMPLOYED";
    case EmploymentType.INTERNSHIP:
      return "INTERNSHIP";
    case EmploymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum IncomeFrequency {
  NOT_USED_INCOMEFREQUENCY = 0,
  HOURLY = 1,
  WEEKLY = 2,
  BI_WEEKLY = 3,
  MONTHLY = 4,
  ANNUALLY = 5,
  UNRECOGNIZED = -1,
}

export function incomeFrequencyFromJSON(object: any): IncomeFrequency {
  switch (object) {
    case 0:
    case "NOT_USED_INCOMEFREQUENCY":
      return IncomeFrequency.NOT_USED_INCOMEFREQUENCY;
    case 1:
    case "HOURLY":
      return IncomeFrequency.HOURLY;
    case 2:
    case "WEEKLY":
      return IncomeFrequency.WEEKLY;
    case 3:
    case "BI_WEEKLY":
      return IncomeFrequency.BI_WEEKLY;
    case 4:
    case "MONTHLY":
      return IncomeFrequency.MONTHLY;
    case 5:
    case "ANNUALLY":
      return IncomeFrequency.ANNUALLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IncomeFrequency.UNRECOGNIZED;
  }
}

export function incomeFrequencyToJSON(object: IncomeFrequency): string {
  switch (object) {
    case IncomeFrequency.NOT_USED_INCOMEFREQUENCY:
      return "NOT_USED_INCOMEFREQUENCY";
    case IncomeFrequency.HOURLY:
      return "HOURLY";
    case IncomeFrequency.WEEKLY:
      return "WEEKLY";
    case IncomeFrequency.BI_WEEKLY:
      return "BI_WEEKLY";
    case IncomeFrequency.MONTHLY:
      return "MONTHLY";
    case IncomeFrequency.ANNUALLY:
      return "ANNUALLY";
    case IncomeFrequency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum KYCStatus {
  /** KYC_STATUS_UNSPECIFIED - Default value, should not be used */
  KYC_STATUS_UNSPECIFIED = 0,
  /** KYC_STATUS_PENDING - Inquiry created but not completed */
  KYC_STATUS_PENDING = 1,
  /** KYC_STATUS_IN_REVIEW - Inquiry submitted but under manual review */
  KYC_STATUS_IN_REVIEW = 2,
  /** KYC_STATUS_APPROVED - Inquiry completed and approved */
  KYC_STATUS_APPROVED = 3,
  /** KYC_STATUS_REJECTED - Inquiry completed and explicitly rejected */
  KYC_STATUS_REJECTED = 4,
  /** KYC_STATUS_FAILED - Inquiry failed due to an error (e.g., document mismatch, bad image quality) */
  KYC_STATUS_FAILED = 5,
  /** KYC_STATUS_EXPIRED - Inquiry expired (e.g., not completed in time) */
  KYC_STATUS_EXPIRED = 6,
  UNRECOGNIZED = -1,
}

export function kYCStatusFromJSON(object: any): KYCStatus {
  switch (object) {
    case 0:
    case "KYC_STATUS_UNSPECIFIED":
      return KYCStatus.KYC_STATUS_UNSPECIFIED;
    case 1:
    case "KYC_STATUS_PENDING":
      return KYCStatus.KYC_STATUS_PENDING;
    case 2:
    case "KYC_STATUS_IN_REVIEW":
      return KYCStatus.KYC_STATUS_IN_REVIEW;
    case 3:
    case "KYC_STATUS_APPROVED":
      return KYCStatus.KYC_STATUS_APPROVED;
    case 4:
    case "KYC_STATUS_REJECTED":
      return KYCStatus.KYC_STATUS_REJECTED;
    case 5:
    case "KYC_STATUS_FAILED":
      return KYCStatus.KYC_STATUS_FAILED;
    case 6:
    case "KYC_STATUS_EXPIRED":
      return KYCStatus.KYC_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KYCStatus.UNRECOGNIZED;
  }
}

export function kYCStatusToJSON(object: KYCStatus): string {
  switch (object) {
    case KYCStatus.KYC_STATUS_UNSPECIFIED:
      return "KYC_STATUS_UNSPECIFIED";
    case KYCStatus.KYC_STATUS_PENDING:
      return "KYC_STATUS_PENDING";
    case KYCStatus.KYC_STATUS_IN_REVIEW:
      return "KYC_STATUS_IN_REVIEW";
    case KYCStatus.KYC_STATUS_APPROVED:
      return "KYC_STATUS_APPROVED";
    case KYCStatus.KYC_STATUS_REJECTED:
      return "KYC_STATUS_REJECTED";
    case KYCStatus.KYC_STATUS_FAILED:
      return "KYC_STATUS_FAILED";
    case KYCStatus.KYC_STATUS_EXPIRED:
      return "KYC_STATUS_EXPIRED";
    case KYCStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface IDNumber {
  IssuingCountry: string;
  IdentificationClass: string;
  IdentificationNumber: string;
}

export interface UserKYCDetails {
  Birthdate: string;
  PhoneNumber: string;
  EmailAddress: string;
  AddressStreet1: string;
  AddressStreet2: string;
  AddressCity: string;
  AddressSubdivision: string;
  AddressPostalCode: string;
  CountryCode: string;
  SocialSecurityNumber: string;
  IdentificationNumber: string;
  FirstName: string;
  LastName: string;
}

export interface Employment {
  EmployerName: string;
  JobTitle: string;
  StartDate:
    | Date
    | undefined;
  /** Empty if still employed */
  EndDate: Date | undefined;
  Type: EmploymentType;
  Industry?: string | undefined;
  Income: Income | undefined;
  Contact: EmployerContact | undefined;
  IsVerified: boolean;
  VerifiedAt: string;
}

export interface Income {
  Amount: number;
  Currency: string;
  Frequency: IncomeFrequency;
}

export interface EmployerContact {
  Name: string;
  Email: string;
  Phone: string;
  Address: string;
}

function createBaseIDNumber(): IDNumber {
  return { IssuingCountry: "", IdentificationClass: "", IdentificationNumber: "" };
}

export const IDNumber = {
  encode(message: IDNumber, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.IssuingCountry !== "") {
      writer.uint32(10).string(message.IssuingCountry);
    }
    if (message.IdentificationClass !== "") {
      writer.uint32(18).string(message.IdentificationClass);
    }
    if (message.IdentificationNumber !== "") {
      writer.uint32(26).string(message.IdentificationNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IDNumber {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIDNumber();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.IssuingCountry = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.IdentificationClass = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.IdentificationNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IDNumber {
    return {
      IssuingCountry: isSet(object.IssuingCountry) ? globalThis.String(object.IssuingCountry) : "",
      IdentificationClass: isSet(object.IdentificationClass) ? globalThis.String(object.IdentificationClass) : "",
      IdentificationNumber: isSet(object.IdentificationNumber) ? globalThis.String(object.IdentificationNumber) : "",
    };
  },

  toJSON(message: IDNumber): unknown {
    const obj: any = {};
    if (message.IssuingCountry !== "") {
      obj.IssuingCountry = message.IssuingCountry;
    }
    if (message.IdentificationClass !== "") {
      obj.IdentificationClass = message.IdentificationClass;
    }
    if (message.IdentificationNumber !== "") {
      obj.IdentificationNumber = message.IdentificationNumber;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IDNumber>, I>>(base?: I): IDNumber {
    return IDNumber.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IDNumber>, I>>(object: I): IDNumber {
    const message = createBaseIDNumber();
    message.IssuingCountry = object.IssuingCountry ?? "";
    message.IdentificationClass = object.IdentificationClass ?? "";
    message.IdentificationNumber = object.IdentificationNumber ?? "";
    return message;
  },
};

function createBaseUserKYCDetails(): UserKYCDetails {
  return {
    Birthdate: "",
    PhoneNumber: "",
    EmailAddress: "",
    AddressStreet1: "",
    AddressStreet2: "",
    AddressCity: "",
    AddressSubdivision: "",
    AddressPostalCode: "",
    CountryCode: "",
    SocialSecurityNumber: "",
    IdentificationNumber: "",
    FirstName: "",
    LastName: "",
  };
}

export const UserKYCDetails = {
  encode(message: UserKYCDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Birthdate !== "") {
      writer.uint32(10).string(message.Birthdate);
    }
    if (message.PhoneNumber !== "") {
      writer.uint32(18).string(message.PhoneNumber);
    }
    if (message.EmailAddress !== "") {
      writer.uint32(26).string(message.EmailAddress);
    }
    if (message.AddressStreet1 !== "") {
      writer.uint32(34).string(message.AddressStreet1);
    }
    if (message.AddressStreet2 !== "") {
      writer.uint32(42).string(message.AddressStreet2);
    }
    if (message.AddressCity !== "") {
      writer.uint32(50).string(message.AddressCity);
    }
    if (message.AddressSubdivision !== "") {
      writer.uint32(58).string(message.AddressSubdivision);
    }
    if (message.AddressPostalCode !== "") {
      writer.uint32(66).string(message.AddressPostalCode);
    }
    if (message.CountryCode !== "") {
      writer.uint32(74).string(message.CountryCode);
    }
    if (message.SocialSecurityNumber !== "") {
      writer.uint32(82).string(message.SocialSecurityNumber);
    }
    if (message.IdentificationNumber !== "") {
      writer.uint32(90).string(message.IdentificationNumber);
    }
    if (message.FirstName !== "") {
      writer.uint32(98).string(message.FirstName);
    }
    if (message.LastName !== "") {
      writer.uint32(106).string(message.LastName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserKYCDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserKYCDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Birthdate = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.PhoneNumber = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.EmailAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.AddressStreet1 = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.AddressStreet2 = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.AddressCity = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.AddressSubdivision = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.AddressPostalCode = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.CountryCode = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.SocialSecurityNumber = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.IdentificationNumber = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.FirstName = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.LastName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserKYCDetails {
    return {
      Birthdate: isSet(object.Birthdate) ? globalThis.String(object.Birthdate) : "",
      PhoneNumber: isSet(object.PhoneNumber) ? globalThis.String(object.PhoneNumber) : "",
      EmailAddress: isSet(object.EmailAddress) ? globalThis.String(object.EmailAddress) : "",
      AddressStreet1: isSet(object.AddressStreet1) ? globalThis.String(object.AddressStreet1) : "",
      AddressStreet2: isSet(object.AddressStreet2) ? globalThis.String(object.AddressStreet2) : "",
      AddressCity: isSet(object.AddressCity) ? globalThis.String(object.AddressCity) : "",
      AddressSubdivision: isSet(object.AddressSubdivision) ? globalThis.String(object.AddressSubdivision) : "",
      AddressPostalCode: isSet(object.AddressPostalCode) ? globalThis.String(object.AddressPostalCode) : "",
      CountryCode: isSet(object.CountryCode) ? globalThis.String(object.CountryCode) : "",
      SocialSecurityNumber: isSet(object.SocialSecurityNumber) ? globalThis.String(object.SocialSecurityNumber) : "",
      IdentificationNumber: isSet(object.IdentificationNumber) ? globalThis.String(object.IdentificationNumber) : "",
      FirstName: isSet(object.FirstName) ? globalThis.String(object.FirstName) : "",
      LastName: isSet(object.LastName) ? globalThis.String(object.LastName) : "",
    };
  },

  toJSON(message: UserKYCDetails): unknown {
    const obj: any = {};
    if (message.Birthdate !== "") {
      obj.Birthdate = message.Birthdate;
    }
    if (message.PhoneNumber !== "") {
      obj.PhoneNumber = message.PhoneNumber;
    }
    if (message.EmailAddress !== "") {
      obj.EmailAddress = message.EmailAddress;
    }
    if (message.AddressStreet1 !== "") {
      obj.AddressStreet1 = message.AddressStreet1;
    }
    if (message.AddressStreet2 !== "") {
      obj.AddressStreet2 = message.AddressStreet2;
    }
    if (message.AddressCity !== "") {
      obj.AddressCity = message.AddressCity;
    }
    if (message.AddressSubdivision !== "") {
      obj.AddressSubdivision = message.AddressSubdivision;
    }
    if (message.AddressPostalCode !== "") {
      obj.AddressPostalCode = message.AddressPostalCode;
    }
    if (message.CountryCode !== "") {
      obj.CountryCode = message.CountryCode;
    }
    if (message.SocialSecurityNumber !== "") {
      obj.SocialSecurityNumber = message.SocialSecurityNumber;
    }
    if (message.IdentificationNumber !== "") {
      obj.IdentificationNumber = message.IdentificationNumber;
    }
    if (message.FirstName !== "") {
      obj.FirstName = message.FirstName;
    }
    if (message.LastName !== "") {
      obj.LastName = message.LastName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserKYCDetails>, I>>(base?: I): UserKYCDetails {
    return UserKYCDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserKYCDetails>, I>>(object: I): UserKYCDetails {
    const message = createBaseUserKYCDetails();
    message.Birthdate = object.Birthdate ?? "";
    message.PhoneNumber = object.PhoneNumber ?? "";
    message.EmailAddress = object.EmailAddress ?? "";
    message.AddressStreet1 = object.AddressStreet1 ?? "";
    message.AddressStreet2 = object.AddressStreet2 ?? "";
    message.AddressCity = object.AddressCity ?? "";
    message.AddressSubdivision = object.AddressSubdivision ?? "";
    message.AddressPostalCode = object.AddressPostalCode ?? "";
    message.CountryCode = object.CountryCode ?? "";
    message.SocialSecurityNumber = object.SocialSecurityNumber ?? "";
    message.IdentificationNumber = object.IdentificationNumber ?? "";
    message.FirstName = object.FirstName ?? "";
    message.LastName = object.LastName ?? "";
    return message;
  },
};

function createBaseEmployment(): Employment {
  return {
    EmployerName: "",
    JobTitle: "",
    StartDate: undefined,
    EndDate: undefined,
    Type: 0,
    Industry: undefined,
    Income: undefined,
    Contact: undefined,
    IsVerified: false,
    VerifiedAt: "",
  };
}

export const Employment = {
  encode(message: Employment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.EmployerName !== "") {
      writer.uint32(10).string(message.EmployerName);
    }
    if (message.JobTitle !== "") {
      writer.uint32(18).string(message.JobTitle);
    }
    if (message.StartDate !== undefined) {
      Timestamp.encode(toTimestamp(message.StartDate), writer.uint32(26).fork()).ldelim();
    }
    if (message.EndDate !== undefined) {
      Timestamp.encode(toTimestamp(message.EndDate), writer.uint32(34).fork()).ldelim();
    }
    if (message.Type !== 0) {
      writer.uint32(40).int32(message.Type);
    }
    if (message.Industry !== undefined) {
      writer.uint32(50).string(message.Industry);
    }
    if (message.Income !== undefined) {
      Income.encode(message.Income, writer.uint32(58).fork()).ldelim();
    }
    if (message.Contact !== undefined) {
      EmployerContact.encode(message.Contact, writer.uint32(66).fork()).ldelim();
    }
    if (message.IsVerified !== false) {
      writer.uint32(72).bool(message.IsVerified);
    }
    if (message.VerifiedAt !== "") {
      writer.uint32(82).string(message.VerifiedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Employment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.EmployerName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.JobTitle = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.StartDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.EndDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Industry = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.Income = Income.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.Contact = EmployerContact.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.IsVerified = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.VerifiedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Employment {
    return {
      EmployerName: isSet(object.EmployerName) ? globalThis.String(object.EmployerName) : "",
      JobTitle: isSet(object.JobTitle) ? globalThis.String(object.JobTitle) : "",
      StartDate: isSet(object.StartDate) ? fromJsonTimestamp(object.StartDate) : undefined,
      EndDate: isSet(object.EndDate) ? fromJsonTimestamp(object.EndDate) : undefined,
      Type: isSet(object.Type) ? employmentTypeFromJSON(object.Type) : 0,
      Industry: isSet(object.Industry) ? globalThis.String(object.Industry) : undefined,
      Income: isSet(object.Income) ? Income.fromJSON(object.Income) : undefined,
      Contact: isSet(object.Contact) ? EmployerContact.fromJSON(object.Contact) : undefined,
      IsVerified: isSet(object.IsVerified) ? globalThis.Boolean(object.IsVerified) : false,
      VerifiedAt: isSet(object.VerifiedAt) ? globalThis.String(object.VerifiedAt) : "",
    };
  },

  toJSON(message: Employment): unknown {
    const obj: any = {};
    if (message.EmployerName !== "") {
      obj.EmployerName = message.EmployerName;
    }
    if (message.JobTitle !== "") {
      obj.JobTitle = message.JobTitle;
    }
    if (message.StartDate !== undefined) {
      obj.StartDate = message.StartDate.toISOString();
    }
    if (message.EndDate !== undefined) {
      obj.EndDate = message.EndDate.toISOString();
    }
    if (message.Type !== 0) {
      obj.Type = employmentTypeToJSON(message.Type);
    }
    if (message.Industry !== undefined) {
      obj.Industry = message.Industry;
    }
    if (message.Income !== undefined) {
      obj.Income = Income.toJSON(message.Income);
    }
    if (message.Contact !== undefined) {
      obj.Contact = EmployerContact.toJSON(message.Contact);
    }
    if (message.IsVerified !== false) {
      obj.IsVerified = message.IsVerified;
    }
    if (message.VerifiedAt !== "") {
      obj.VerifiedAt = message.VerifiedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Employment>, I>>(base?: I): Employment {
    return Employment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Employment>, I>>(object: I): Employment {
    const message = createBaseEmployment();
    message.EmployerName = object.EmployerName ?? "";
    message.JobTitle = object.JobTitle ?? "";
    message.StartDate = object.StartDate ?? undefined;
    message.EndDate = object.EndDate ?? undefined;
    message.Type = object.Type ?? 0;
    message.Industry = object.Industry ?? undefined;
    message.Income = (object.Income !== undefined && object.Income !== null)
      ? Income.fromPartial(object.Income)
      : undefined;
    message.Contact = (object.Contact !== undefined && object.Contact !== null)
      ? EmployerContact.fromPartial(object.Contact)
      : undefined;
    message.IsVerified = object.IsVerified ?? false;
    message.VerifiedAt = object.VerifiedAt ?? "";
    return message;
  },
};

function createBaseIncome(): Income {
  return { Amount: 0, Currency: "", Frequency: 0 };
}

export const Income = {
  encode(message: Income, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Amount !== 0) {
      writer.uint32(13).float(message.Amount);
    }
    if (message.Currency !== "") {
      writer.uint32(18).string(message.Currency);
    }
    if (message.Frequency !== 0) {
      writer.uint32(24).int32(message.Frequency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Income {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncome();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.Amount = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Currency = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Frequency = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Income {
    return {
      Amount: isSet(object.Amount) ? globalThis.Number(object.Amount) : 0,
      Currency: isSet(object.Currency) ? globalThis.String(object.Currency) : "",
      Frequency: isSet(object.Frequency) ? incomeFrequencyFromJSON(object.Frequency) : 0,
    };
  },

  toJSON(message: Income): unknown {
    const obj: any = {};
    if (message.Amount !== 0) {
      obj.Amount = message.Amount;
    }
    if (message.Currency !== "") {
      obj.Currency = message.Currency;
    }
    if (message.Frequency !== 0) {
      obj.Frequency = incomeFrequencyToJSON(message.Frequency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Income>, I>>(base?: I): Income {
    return Income.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Income>, I>>(object: I): Income {
    const message = createBaseIncome();
    message.Amount = object.Amount ?? 0;
    message.Currency = object.Currency ?? "";
    message.Frequency = object.Frequency ?? 0;
    return message;
  },
};

function createBaseEmployerContact(): EmployerContact {
  return { Name: "", Email: "", Phone: "", Address: "" };
}

export const EmployerContact = {
  encode(message: EmployerContact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Name !== "") {
      writer.uint32(10).string(message.Name);
    }
    if (message.Email !== "") {
      writer.uint32(18).string(message.Email);
    }
    if (message.Phone !== "") {
      writer.uint32(26).string(message.Phone);
    }
    if (message.Address !== "") {
      writer.uint32(34).string(message.Address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EmployerContact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmployerContact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Phone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmployerContact {
    return {
      Name: isSet(object.Name) ? globalThis.String(object.Name) : "",
      Email: isSet(object.Email) ? globalThis.String(object.Email) : "",
      Phone: isSet(object.Phone) ? globalThis.String(object.Phone) : "",
      Address: isSet(object.Address) ? globalThis.String(object.Address) : "",
    };
  },

  toJSON(message: EmployerContact): unknown {
    const obj: any = {};
    if (message.Name !== "") {
      obj.Name = message.Name;
    }
    if (message.Email !== "") {
      obj.Email = message.Email;
    }
    if (message.Phone !== "") {
      obj.Phone = message.Phone;
    }
    if (message.Address !== "") {
      obj.Address = message.Address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmployerContact>, I>>(base?: I): EmployerContact {
    return EmployerContact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmployerContact>, I>>(object: I): EmployerContact {
    const message = createBaseEmployerContact();
    message.Name = object.Name ?? "";
    message.Email = object.Email ?? "";
    message.Phone = object.Phone ?? "";
    message.Address = object.Address ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
