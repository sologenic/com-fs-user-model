// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: sologenic/com-fs-order-model/util.proto
/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
export const protobufPackage = "order";
export var OrderType;
(function (OrderType) {
    OrderType[OrderType["NOT_USED_ORDER_TYPE"] = 0] = "NOT_USED_ORDER_TYPE";
    /** ORDER_TYPE_PURCHASE - Avoid naming conflicts with PURCHASE in the action enum */
    OrderType[OrderType["ORDER_TYPE_PURCHASE"] = 1] = "ORDER_TYPE_PURCHASE";
    OrderType[OrderType["ORDER_TYPE_SELL"] = 2] = "ORDER_TYPE_SELL";
    OrderType[OrderType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderType || (OrderType = {}));
export function orderTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "NOT_USED_ORDER_TYPE":
            return OrderType.NOT_USED_ORDER_TYPE;
        case 1:
        case "ORDER_TYPE_PURCHASE":
            return OrderType.ORDER_TYPE_PURCHASE;
        case 2:
        case "ORDER_TYPE_SELL":
            return OrderType.ORDER_TYPE_SELL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OrderType.UNRECOGNIZED;
    }
}
export function orderTypeToJSON(object) {
    switch (object) {
        case OrderType.NOT_USED_ORDER_TYPE:
            return "NOT_USED_ORDER_TYPE";
        case OrderType.ORDER_TYPE_PURCHASE:
            return "ORDER_TYPE_PURCHASE";
        case OrderType.ORDER_TYPE_SELL:
            return "ORDER_TYPE_SELL";
        case OrderType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var TimeInForce;
(function (TimeInForce) {
    TimeInForce[TimeInForce["NOT_USED_TIME_IN_FORCE"] = 0] = "NOT_USED_TIME_IN_FORCE";
    TimeInForce[TimeInForce["DAY"] = 1] = "DAY";
    /** GOOD_TIL_CANCELED - GTC */
    TimeInForce[TimeInForce["GOOD_TIL_CANCELED"] = 2] = "GOOD_TIL_CANCELED";
    /** AT_THE_OPENING - OPG */
    TimeInForce[TimeInForce["AT_THE_OPENING"] = 3] = "AT_THE_OPENING";
    /** AT_THE_CLOSE - CLS */
    TimeInForce[TimeInForce["AT_THE_CLOSE"] = 4] = "AT_THE_CLOSE";
    /** IMMEDIATE_OR_CANCEL - IOC */
    TimeInForce[TimeInForce["IMMEDIATE_OR_CANCEL"] = 5] = "IMMEDIATE_OR_CANCEL";
    /** FILL_OR_KILL - FOK */
    TimeInForce[TimeInForce["FILL_OR_KILL"] = 6] = "FILL_OR_KILL";
    /** GOOD_TIL_TIME - GTT */
    TimeInForce[TimeInForce["GOOD_TIL_TIME"] = 7] = "GOOD_TIL_TIME";
    TimeInForce[TimeInForce["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TimeInForce || (TimeInForce = {}));
export function timeInForceFromJSON(object) {
    switch (object) {
        case 0:
        case "NOT_USED_TIME_IN_FORCE":
            return TimeInForce.NOT_USED_TIME_IN_FORCE;
        case 1:
        case "DAY":
            return TimeInForce.DAY;
        case 2:
        case "GOOD_TIL_CANCELED":
            return TimeInForce.GOOD_TIL_CANCELED;
        case 3:
        case "AT_THE_OPENING":
            return TimeInForce.AT_THE_OPENING;
        case 4:
        case "AT_THE_CLOSE":
            return TimeInForce.AT_THE_CLOSE;
        case 5:
        case "IMMEDIATE_OR_CANCEL":
            return TimeInForce.IMMEDIATE_OR_CANCEL;
        case 6:
        case "FILL_OR_KILL":
            return TimeInForce.FILL_OR_KILL;
        case 7:
        case "GOOD_TIL_TIME":
            return TimeInForce.GOOD_TIL_TIME;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TimeInForce.UNRECOGNIZED;
    }
}
export function timeInForceToJSON(object) {
    switch (object) {
        case TimeInForce.NOT_USED_TIME_IN_FORCE:
            return "NOT_USED_TIME_IN_FORCE";
        case TimeInForce.DAY:
            return "DAY";
        case TimeInForce.GOOD_TIL_CANCELED:
            return "GOOD_TIL_CANCELED";
        case TimeInForce.AT_THE_OPENING:
            return "AT_THE_OPENING";
        case TimeInForce.AT_THE_CLOSE:
            return "AT_THE_CLOSE";
        case TimeInForce.IMMEDIATE_OR_CANCEL:
            return "IMMEDIATE_OR_CANCEL";
        case TimeInForce.FILL_OR_KILL:
            return "FILL_OR_KILL";
        case TimeInForce.GOOD_TIL_TIME:
            return "GOOD_TIL_TIME";
        case TimeInForce.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var ProcessState;
(function (ProcessState) {
    ProcessState[ProcessState["NOT_USED_PROCESS_STATE"] = 0] = "NOT_USED_PROCESS_STATE";
    ProcessState[ProcessState["PROCESS_STATE_OPEN"] = 1] = "PROCESS_STATE_OPEN";
    ProcessState[ProcessState["PROCESS_STATE_LOCKED"] = 2] = "PROCESS_STATE_LOCKED";
    ProcessState[ProcessState["PROCESS_STATE_FAILED"] = 3] = "PROCESS_STATE_FAILED";
    ProcessState[ProcessState["PROCESS_STATE_PROCESSED"] = 4] = "PROCESS_STATE_PROCESSED";
    ProcessState[ProcessState["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ProcessState || (ProcessState = {}));
export function processStateFromJSON(object) {
    switch (object) {
        case 0:
        case "NOT_USED_PROCESS_STATE":
            return ProcessState.NOT_USED_PROCESS_STATE;
        case 1:
        case "PROCESS_STATE_OPEN":
            return ProcessState.PROCESS_STATE_OPEN;
        case 2:
        case "PROCESS_STATE_LOCKED":
            return ProcessState.PROCESS_STATE_LOCKED;
        case 3:
        case "PROCESS_STATE_FAILED":
            return ProcessState.PROCESS_STATE_FAILED;
        case 4:
        case "PROCESS_STATE_PROCESSED":
            return ProcessState.PROCESS_STATE_PROCESSED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ProcessState.UNRECOGNIZED;
    }
}
export function processStateToJSON(object) {
    switch (object) {
        case ProcessState.NOT_USED_PROCESS_STATE:
            return "NOT_USED_PROCESS_STATE";
        case ProcessState.PROCESS_STATE_OPEN:
            return "PROCESS_STATE_OPEN";
        case ProcessState.PROCESS_STATE_LOCKED:
            return "PROCESS_STATE_LOCKED";
        case ProcessState.PROCESS_STATE_FAILED:
            return "PROCESS_STATE_FAILED";
        case ProcessState.PROCESS_STATE_PROCESSED:
            return "PROCESS_STATE_PROCESSED";
        case ProcessState.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseProcessInfo() {
    return { ProcessState: 0, ProcessedAt: undefined };
}
export const ProcessInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.ProcessState !== 0) {
            writer.uint32(8).int32(message.ProcessState);
        }
        if (message.ProcessedAt !== undefined) {
            Timestamp.encode(toTimestamp(message.ProcessedAt), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProcessInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.ProcessState = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ProcessedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ProcessState: isSet(object.ProcessState) ? processStateFromJSON(object.ProcessState) : 0,
            ProcessedAt: isSet(object.ProcessedAt) ? fromJsonTimestamp(object.ProcessedAt) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ProcessState !== 0) {
            obj.ProcessState = processStateToJSON(message.ProcessState);
        }
        if (message.ProcessedAt !== undefined) {
            obj.ProcessedAt = message.ProcessedAt.toISOString();
        }
        return obj;
    },
    create(base) {
        return ProcessInfo.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseProcessInfo();
        message.ProcessState = (_a = object.ProcessState) !== null && _a !== void 0 ? _a : 0;
        message.ProcessedAt = (_b = object.ProcessedAt) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseLockLogRecord() {
    return { Key: "", MustHaveState: [], TargetState: 0 };
}
export const LockLogRecord = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.Key !== "") {
            writer.uint32(10).string(message.Key);
        }
        writer.uint32(18).fork();
        for (const v of message.MustHaveState) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.TargetState !== 0) {
            writer.uint32(24).int32(message.TargetState);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLockLogRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.Key = reader.string();
                    continue;
                case 2:
                    if (tag === 16) {
                        message.MustHaveState.push(reader.int32());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.MustHaveState.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.TargetState = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Key: isSet(object.Key) ? globalThis.String(object.Key) : "",
            MustHaveState: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.MustHaveState)
                ? object.MustHaveState.map((e) => processStateFromJSON(e))
                : [],
            TargetState: isSet(object.TargetState) ? processStateFromJSON(object.TargetState) : 0,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.Key !== "") {
            obj.Key = message.Key;
        }
        if ((_a = message.MustHaveState) === null || _a === void 0 ? void 0 : _a.length) {
            obj.MustHaveState = message.MustHaveState.map((e) => processStateToJSON(e));
        }
        if (message.TargetState !== 0) {
            obj.TargetState = processStateToJSON(message.TargetState);
        }
        return obj;
    },
    create(base) {
        return LockLogRecord.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseLockLogRecord();
        message.Key = (_a = object.Key) !== null && _a !== void 0 ? _a : "";
        message.MustHaveState = ((_b = object.MustHaveState) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.TargetState = (_c = object.TargetState) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseKey() {
    return { Key: "", KeyPrefix: undefined, IsNew: undefined };
}
export const Key = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.Key !== "") {
            writer.uint32(10).string(message.Key);
        }
        if (message.KeyPrefix !== undefined) {
            writer.uint32(18).string(message.KeyPrefix);
        }
        if (message.IsNew !== undefined) {
            writer.uint32(24).bool(message.IsNew);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.Key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.KeyPrefix = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.IsNew = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Key: isSet(object.Key) ? globalThis.String(object.Key) : "",
            KeyPrefix: isSet(object.KeyPrefix) ? globalThis.String(object.KeyPrefix) : undefined,
            IsNew: isSet(object.IsNew) ? globalThis.Boolean(object.IsNew) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.Key !== "") {
            obj.Key = message.Key;
        }
        if (message.KeyPrefix !== undefined) {
            obj.KeyPrefix = message.KeyPrefix;
        }
        if (message.IsNew !== undefined) {
            obj.IsNew = message.IsNew;
        }
        return obj;
    },
    create(base) {
        return Key.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseKey();
        message.Key = (_a = object.Key) !== null && _a !== void 0 ? _a : "";
        message.KeyPrefix = (_b = object.KeyPrefix) !== null && _b !== void 0 ? _b : undefined;
        message.IsNew = (_c = object.IsNew) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseInstanceID() {
    return { InstanceID: "" };
}
export const InstanceID = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.InstanceID !== "") {
            writer.uint32(10).string(message.InstanceID);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstanceID();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.InstanceID = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { InstanceID: isSet(object.InstanceID) ? globalThis.String(object.InstanceID) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.InstanceID !== "") {
            obj.InstanceID = message.InstanceID;
        }
        return obj;
    },
    create(base) {
        return InstanceID.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseInstanceID();
        message.InstanceID = (_a = object.InstanceID) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
