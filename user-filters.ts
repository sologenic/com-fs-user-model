// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.30.2
// source: user-filters.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Network, networkFromJSON, networkToJSON } from "./sologenic/com-fs-utils-lib/models/metadata/metadata";
import { UserStatus, userStatusFromJSON, userStatusToJSON } from "./user";

export const protobufPackage = "user";

export interface Filter {
  UserIDs: string[];
  Network?: Network | undefined;
  OrganizationID: string;
  Offset?: number | undefined;
  Limit?: number | undefined;
  InquiryID?: string | undefined;
  Status?: UserStatus | undefined;
  ExternalUserIDs: string[];
  WalletAddress?: string | undefined;
  BrokerAccountID?: string | undefined;
}

export interface UserID {
  UserID: string;
  OrganizationID: string;
  Network?: Network | undefined;
}

function createBaseFilter(): Filter {
  return {
    UserIDs: [],
    Network: undefined,
    OrganizationID: "",
    Offset: undefined,
    Limit: undefined,
    InquiryID: undefined,
    Status: undefined,
    ExternalUserIDs: [],
    WalletAddress: undefined,
    BrokerAccountID: undefined,
  };
}

export const Filter = {
  encode(message: Filter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.UserIDs) {
      writer.uint32(10).string(v!);
    }
    if (message.Network !== undefined) {
      writer.uint32(16).int32(message.Network);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(26).string(message.OrganizationID);
    }
    if (message.Offset !== undefined) {
      writer.uint32(32).int32(message.Offset);
    }
    if (message.Limit !== undefined) {
      writer.uint32(40).int32(message.Limit);
    }
    if (message.InquiryID !== undefined) {
      writer.uint32(50).string(message.InquiryID);
    }
    if (message.Status !== undefined) {
      writer.uint32(56).int32(message.Status);
    }
    for (const v of message.ExternalUserIDs) {
      writer.uint32(66).string(v!);
    }
    if (message.WalletAddress !== undefined) {
      writer.uint32(74).string(message.WalletAddress);
    }
    if (message.BrokerAccountID !== undefined) {
      writer.uint32(82).string(message.BrokerAccountID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Filter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserIDs.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Network = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.Offset = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.Limit = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.InquiryID = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ExternalUserIDs.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.WalletAddress = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.BrokerAccountID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      UserIDs: globalThis.Array.isArray(object?.UserIDs) ? object.UserIDs.map((e: any) => globalThis.String(e)) : [],
      Network: isSet(object.Network) ? networkFromJSON(object.Network) : undefined,
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Offset: isSet(object.Offset) ? globalThis.Number(object.Offset) : undefined,
      Limit: isSet(object.Limit) ? globalThis.Number(object.Limit) : undefined,
      InquiryID: isSet(object.InquiryID) ? globalThis.String(object.InquiryID) : undefined,
      Status: isSet(object.Status) ? userStatusFromJSON(object.Status) : undefined,
      ExternalUserIDs: globalThis.Array.isArray(object?.ExternalUserIDs)
        ? object.ExternalUserIDs.map((e: any) => globalThis.String(e))
        : [],
      WalletAddress: isSet(object.WalletAddress) ? globalThis.String(object.WalletAddress) : undefined,
      BrokerAccountID: isSet(object.BrokerAccountID) ? globalThis.String(object.BrokerAccountID) : undefined,
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.UserIDs?.length) {
      obj.UserIDs = message.UserIDs;
    }
    if (message.Network !== undefined) {
      obj.Network = networkToJSON(message.Network);
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Offset !== undefined) {
      obj.Offset = Math.round(message.Offset);
    }
    if (message.Limit !== undefined) {
      obj.Limit = Math.round(message.Limit);
    }
    if (message.InquiryID !== undefined) {
      obj.InquiryID = message.InquiryID;
    }
    if (message.Status !== undefined) {
      obj.Status = userStatusToJSON(message.Status);
    }
    if (message.ExternalUserIDs?.length) {
      obj.ExternalUserIDs = message.ExternalUserIDs;
    }
    if (message.WalletAddress !== undefined) {
      obj.WalletAddress = message.WalletAddress;
    }
    if (message.BrokerAccountID !== undefined) {
      obj.BrokerAccountID = message.BrokerAccountID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Filter>, I>>(base?: I): Filter {
    return Filter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Filter>, I>>(object: I): Filter {
    const message = createBaseFilter();
    message.UserIDs = object.UserIDs?.map((e) => e) || [];
    message.Network = object.Network ?? undefined;
    message.OrganizationID = object.OrganizationID ?? "";
    message.Offset = object.Offset ?? undefined;
    message.Limit = object.Limit ?? undefined;
    message.InquiryID = object.InquiryID ?? undefined;
    message.Status = object.Status ?? undefined;
    message.ExternalUserIDs = object.ExternalUserIDs?.map((e) => e) || [];
    message.WalletAddress = object.WalletAddress ?? undefined;
    message.BrokerAccountID = object.BrokerAccountID ?? undefined;
    return message;
  },
};

function createBaseUserID(): UserID {
  return { UserID: "", OrganizationID: "", Network: undefined };
}

export const UserID = {
  encode(message: UserID, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.UserID !== "") {
      writer.uint32(10).string(message.UserID);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(18).string(message.OrganizationID);
    }
    if (message.Network !== undefined) {
      writer.uint32(24).int32(message.Network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserID {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Network = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserID {
    return {
      UserID: isSet(object.UserID) ? globalThis.String(object.UserID) : "",
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Network: isSet(object.Network) ? networkFromJSON(object.Network) : undefined,
    };
  },

  toJSON(message: UserID): unknown {
    const obj: any = {};
    if (message.UserID !== "") {
      obj.UserID = message.UserID;
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Network !== undefined) {
      obj.Network = networkToJSON(message.Network);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserID>, I>>(base?: I): UserID {
    return UserID.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserID>, I>>(object: I): UserID {
    const message = createBaseUserID();
    message.UserID = object.UserID ?? "";
    message.OrganizationID = object.OrganizationID ?? "";
    message.Network = object.Network ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
