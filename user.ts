// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: user.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Timestamp } from "./google/protobuf/timestamp";
import { Audit } from "./sologenic/com-fs-utils-lib/models/audit/audit";
import {
  MetaData,
  Network,
  networkFromJSON,
  networkToJSON,
} from "./sologenic/com-fs-utils-lib/models/metadata/metadata";
import { Role, roleFromJSON, roleToJSON } from "./sologenic/com-fs-utils-lib/models/role/role";

export const protobufPackage = "user";

export enum EmploymentType {
  NOT_USED_EMPLOYMENTTYPE = 0,
  FULL_TIME = 1,
  PART_TIME = 2,
  CONTRACT = 3,
  FREELANCE = 4,
  SELF_EMPLOYED = 5,
  INTERNSHIP = 6,
  UNRECOGNIZED = -1,
}

export function employmentTypeFromJSON(object: any): EmploymentType {
  switch (object) {
    case 0:
    case "NOT_USED_EMPLOYMENTTYPE":
      return EmploymentType.NOT_USED_EMPLOYMENTTYPE;
    case 1:
    case "FULL_TIME":
      return EmploymentType.FULL_TIME;
    case 2:
    case "PART_TIME":
      return EmploymentType.PART_TIME;
    case 3:
    case "CONTRACT":
      return EmploymentType.CONTRACT;
    case 4:
    case "FREELANCE":
      return EmploymentType.FREELANCE;
    case 5:
    case "SELF_EMPLOYED":
      return EmploymentType.SELF_EMPLOYED;
    case 6:
    case "INTERNSHIP":
      return EmploymentType.INTERNSHIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EmploymentType.UNRECOGNIZED;
  }
}

export function employmentTypeToJSON(object: EmploymentType): string {
  switch (object) {
    case EmploymentType.NOT_USED_EMPLOYMENTTYPE:
      return "NOT_USED_EMPLOYMENTTYPE";
    case EmploymentType.FULL_TIME:
      return "FULL_TIME";
    case EmploymentType.PART_TIME:
      return "PART_TIME";
    case EmploymentType.CONTRACT:
      return "CONTRACT";
    case EmploymentType.FREELANCE:
      return "FREELANCE";
    case EmploymentType.SELF_EMPLOYED:
      return "SELF_EMPLOYED";
    case EmploymentType.INTERNSHIP:
      return "INTERNSHIP";
    case EmploymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum IncomeFrequency {
  NOT_USED_INCOMEFREQUENCY = 0,
  HOURLY = 1,
  WEEKLY = 2,
  BI_WEEKLY = 3,
  MONTHLY = 4,
  ANNUALLY = 5,
  UNRECOGNIZED = -1,
}

export function incomeFrequencyFromJSON(object: any): IncomeFrequency {
  switch (object) {
    case 0:
    case "NOT_USED_INCOMEFREQUENCY":
      return IncomeFrequency.NOT_USED_INCOMEFREQUENCY;
    case 1:
    case "HOURLY":
      return IncomeFrequency.HOURLY;
    case 2:
    case "WEEKLY":
      return IncomeFrequency.WEEKLY;
    case 3:
    case "BI_WEEKLY":
      return IncomeFrequency.BI_WEEKLY;
    case 4:
    case "MONTHLY":
      return IncomeFrequency.MONTHLY;
    case 5:
    case "ANNUALLY":
      return IncomeFrequency.ANNUALLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IncomeFrequency.UNRECOGNIZED;
  }
}

export function incomeFrequencyToJSON(object: IncomeFrequency): string {
  switch (object) {
    case IncomeFrequency.NOT_USED_INCOMEFREQUENCY:
      return "NOT_USED_INCOMEFREQUENCY";
    case IncomeFrequency.HOURLY:
      return "HOURLY";
    case IncomeFrequency.WEEKLY:
      return "WEEKLY";
    case IncomeFrequency.BI_WEEKLY:
      return "BI_WEEKLY";
    case IncomeFrequency.MONTHLY:
      return "MONTHLY";
    case IncomeFrequency.ANNUALLY:
      return "ANNUALLY";
    case IncomeFrequency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UserStatus {
  NOT_USED_USERSTATUS = 0,
  ACTIVE = 1,
  ADMIN_DEACTIVATED = 2,
  UNRECOGNIZED = -1,
}

export function userStatusFromJSON(object: any): UserStatus {
  switch (object) {
    case 0:
    case "NOT_USED_USERSTATUS":
      return UserStatus.NOT_USED_USERSTATUS;
    case 1:
    case "ACTIVE":
      return UserStatus.ACTIVE;
    case 2:
    case "ADMIN_DEACTIVATED":
      return UserStatus.ADMIN_DEACTIVATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserStatus.UNRECOGNIZED;
  }
}

export function userStatusToJSON(object: UserStatus): string {
  switch (object) {
    case UserStatus.NOT_USED_USERSTATUS:
      return "NOT_USED_USERSTATUS";
    case UserStatus.ACTIVE:
      return "ACTIVE";
    case UserStatus.ADMIN_DEACTIVATED:
      return "ADMIN_DEACTIVATED";
    case UserStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WalletType {
  NOT_USED_WALLETTYPE = 0,
  TFSA = 1,
  RRSP = 2,
  STANDARD = 3,
  UNRECOGNIZED = -1,
}

export function walletTypeFromJSON(object: any): WalletType {
  switch (object) {
    case 0:
    case "NOT_USED_WALLETTYPE":
      return WalletType.NOT_USED_WALLETTYPE;
    case 1:
    case "TFSA":
      return WalletType.TFSA;
    case 2:
    case "RRSP":
      return WalletType.RRSP;
    case 3:
    case "STANDARD":
      return WalletType.STANDARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WalletType.UNRECOGNIZED;
  }
}

export function walletTypeToJSON(object: WalletType): string {
  switch (object) {
    case WalletType.NOT_USED_WALLETTYPE:
      return "NOT_USED_WALLETTYPE";
    case WalletType.TFSA:
      return "TFSA";
    case WalletType.RRSP:
      return "RRSP";
    case WalletType.STANDARD:
      return "STANDARD";
    case WalletType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SocialType {
  NOT_USED_SOCIALTYPE = 0,
  WEBSITE = 1,
  GITHUB = 2,
  REDDIT = 3,
  DISCORD = 4,
  TWITTER = 5,
  FACEBOOK = 6,
  TELEGRAM = 7,
  INSTAGRAM = 8,
  LINKEDIN = 9,
  UNRECOGNIZED = -1,
}

export function socialTypeFromJSON(object: any): SocialType {
  switch (object) {
    case 0:
    case "NOT_USED_SOCIALTYPE":
      return SocialType.NOT_USED_SOCIALTYPE;
    case 1:
    case "WEBSITE":
      return SocialType.WEBSITE;
    case 2:
    case "GITHUB":
      return SocialType.GITHUB;
    case 3:
    case "REDDIT":
      return SocialType.REDDIT;
    case 4:
    case "DISCORD":
      return SocialType.DISCORD;
    case 5:
    case "TWITTER":
      return SocialType.TWITTER;
    case 6:
    case "FACEBOOK":
      return SocialType.FACEBOOK;
    case 7:
    case "TELEGRAM":
      return SocialType.TELEGRAM;
    case 8:
    case "INSTAGRAM":
      return SocialType.INSTAGRAM;
    case 9:
    case "LINKEDIN":
      return SocialType.LINKEDIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SocialType.UNRECOGNIZED;
  }
}

export function socialTypeToJSON(object: SocialType): string {
  switch (object) {
    case SocialType.NOT_USED_SOCIALTYPE:
      return "NOT_USED_SOCIALTYPE";
    case SocialType.WEBSITE:
      return "WEBSITE";
    case SocialType.GITHUB:
      return "GITHUB";
    case SocialType.REDDIT:
      return "REDDIT";
    case SocialType.DISCORD:
      return "DISCORD";
    case SocialType.TWITTER:
      return "TWITTER";
    case SocialType.FACEBOOK:
      return "FACEBOOK";
    case SocialType.TELEGRAM:
      return "TELEGRAM";
    case SocialType.INSTAGRAM:
      return "INSTAGRAM";
    case SocialType.LINKEDIN:
      return "LINKEDIN";
    case SocialType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface UserDetails {
  /** email address used for firebase authentication */
  UserID: string;
  FirstName: string;
  LastName: string;
  Address: string;
  Avatar: string;
  /** "Nickname" */
  Alias: string;
  Description: string;
  Status: UserStatus;
  Wallets: Wallet[];
  Socials: Social[];
  Language:
    | Language
    | undefined;
  /** UUID for the external user identifier in the KYC provider */
  ExternalUserID: string;
  /** UUID */
  OrganizationID: string;
  Employment?:
    | Employment
    | undefined;
  /** A retail user will always have a role of "NORMAL_USER" */
  Role: Role;
}

/** TODO: to be verified when more information is available */
export interface Employment {
  EmployerName: string;
  JobTitle: string;
  StartDate:
    | Date
    | undefined;
  /** Empty if still employed */
  EndDate: Date | undefined;
  Type: EmploymentType;
  Industry?: string | undefined;
  Income: Income | undefined;
  Contact: EmployerContact | undefined;
  IsVerified: boolean;
  VerifiedAt: string;
}

export interface Income {
  Amount: number;
  Currency: string;
  Frequency: IncomeFrequency;
}

export interface EmployerContact {
  Name: string;
  Email: string;
  Phone: string;
  Address: string;
}

export interface User {
  User: UserDetails | undefined;
  MetaData: MetaData | undefined;
  Audit: Audit | undefined;
}

export interface UserID {
  UserID: string;
  OrganizationID: string;
  Network?: Network | undefined;
}

export interface Social {
  URL: string;
  Type: SocialType;
}

export interface Wallet {
  Address: string;
  Alias: string;
  Type: WalletType;
}

export interface Language {
  UserID: string;
  Language: string;
  UserConfigured: boolean;
  Network: string;
}

export interface UserList {
  Users: User[];
  Total: number;
}

export interface SetStatusMessage {
  UserID: string;
  OrganizationID: string;
  Status: UserStatus;
  Network?: Network | undefined;
  Audit: Audit | undefined;
}

function createBaseUserDetails(): UserDetails {
  return {
    UserID: "",
    FirstName: "",
    LastName: "",
    Address: "",
    Avatar: "",
    Alias: "",
    Description: "",
    Status: 0,
    Wallets: [],
    Socials: [],
    Language: undefined,
    ExternalUserID: "",
    OrganizationID: "",
    Employment: undefined,
    Role: 0,
  };
}

export const UserDetails = {
  encode(message: UserDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.UserID !== "") {
      writer.uint32(10).string(message.UserID);
    }
    if (message.FirstName !== "") {
      writer.uint32(18).string(message.FirstName);
    }
    if (message.LastName !== "") {
      writer.uint32(26).string(message.LastName);
    }
    if (message.Address !== "") {
      writer.uint32(34).string(message.Address);
    }
    if (message.Avatar !== "") {
      writer.uint32(42).string(message.Avatar);
    }
    if (message.Alias !== "") {
      writer.uint32(50).string(message.Alias);
    }
    if (message.Description !== "") {
      writer.uint32(58).string(message.Description);
    }
    if (message.Status !== 0) {
      writer.uint32(64).int32(message.Status);
    }
    for (const v of message.Wallets) {
      Wallet.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.Socials) {
      Social.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    if (message.Language !== undefined) {
      Language.encode(message.Language, writer.uint32(90).fork()).ldelim();
    }
    if (message.ExternalUserID !== "") {
      writer.uint32(98).string(message.ExternalUserID);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(106).string(message.OrganizationID);
    }
    if (message.Employment !== undefined) {
      Employment.encode(message.Employment, writer.uint32(114).fork()).ldelim();
    }
    if (message.Role !== 0) {
      writer.uint32(120).int32(message.Role);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.FirstName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.LastName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Address = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Avatar = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Alias = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.Description = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.Wallets.push(Wallet.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.Socials.push(Social.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.Language = Language.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.ExternalUserID = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.Employment = Employment.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.Role = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDetails {
    return {
      UserID: isSet(object.UserID) ? globalThis.String(object.UserID) : "",
      FirstName: isSet(object.FirstName) ? globalThis.String(object.FirstName) : "",
      LastName: isSet(object.LastName) ? globalThis.String(object.LastName) : "",
      Address: isSet(object.Address) ? globalThis.String(object.Address) : "",
      Avatar: isSet(object.Avatar) ? globalThis.String(object.Avatar) : "",
      Alias: isSet(object.Alias) ? globalThis.String(object.Alias) : "",
      Description: isSet(object.Description) ? globalThis.String(object.Description) : "",
      Status: isSet(object.Status) ? userStatusFromJSON(object.Status) : 0,
      Wallets: globalThis.Array.isArray(object?.Wallets) ? object.Wallets.map((e: any) => Wallet.fromJSON(e)) : [],
      Socials: globalThis.Array.isArray(object?.Socials) ? object.Socials.map((e: any) => Social.fromJSON(e)) : [],
      Language: isSet(object.Language) ? Language.fromJSON(object.Language) : undefined,
      ExternalUserID: isSet(object.ExternalUserID) ? globalThis.String(object.ExternalUserID) : "",
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Employment: isSet(object.Employment) ? Employment.fromJSON(object.Employment) : undefined,
      Role: isSet(object.Role) ? roleFromJSON(object.Role) : 0,
    };
  },

  toJSON(message: UserDetails): unknown {
    const obj: any = {};
    if (message.UserID !== "") {
      obj.UserID = message.UserID;
    }
    if (message.FirstName !== "") {
      obj.FirstName = message.FirstName;
    }
    if (message.LastName !== "") {
      obj.LastName = message.LastName;
    }
    if (message.Address !== "") {
      obj.Address = message.Address;
    }
    if (message.Avatar !== "") {
      obj.Avatar = message.Avatar;
    }
    if (message.Alias !== "") {
      obj.Alias = message.Alias;
    }
    if (message.Description !== "") {
      obj.Description = message.Description;
    }
    if (message.Status !== 0) {
      obj.Status = userStatusToJSON(message.Status);
    }
    if (message.Wallets?.length) {
      obj.Wallets = message.Wallets.map((e) => Wallet.toJSON(e));
    }
    if (message.Socials?.length) {
      obj.Socials = message.Socials.map((e) => Social.toJSON(e));
    }
    if (message.Language !== undefined) {
      obj.Language = Language.toJSON(message.Language);
    }
    if (message.ExternalUserID !== "") {
      obj.ExternalUserID = message.ExternalUserID;
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Employment !== undefined) {
      obj.Employment = Employment.toJSON(message.Employment);
    }
    if (message.Role !== 0) {
      obj.Role = roleToJSON(message.Role);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserDetails>, I>>(base?: I): UserDetails {
    return UserDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserDetails>, I>>(object: I): UserDetails {
    const message = createBaseUserDetails();
    message.UserID = object.UserID ?? "";
    message.FirstName = object.FirstName ?? "";
    message.LastName = object.LastName ?? "";
    message.Address = object.Address ?? "";
    message.Avatar = object.Avatar ?? "";
    message.Alias = object.Alias ?? "";
    message.Description = object.Description ?? "";
    message.Status = object.Status ?? 0;
    message.Wallets = object.Wallets?.map((e) => Wallet.fromPartial(e)) || [];
    message.Socials = object.Socials?.map((e) => Social.fromPartial(e)) || [];
    message.Language = (object.Language !== undefined && object.Language !== null)
      ? Language.fromPartial(object.Language)
      : undefined;
    message.ExternalUserID = object.ExternalUserID ?? "";
    message.OrganizationID = object.OrganizationID ?? "";
    message.Employment = (object.Employment !== undefined && object.Employment !== null)
      ? Employment.fromPartial(object.Employment)
      : undefined;
    message.Role = object.Role ?? 0;
    return message;
  },
};

function createBaseEmployment(): Employment {
  return {
    EmployerName: "",
    JobTitle: "",
    StartDate: undefined,
    EndDate: undefined,
    Type: 0,
    Industry: undefined,
    Income: undefined,
    Contact: undefined,
    IsVerified: false,
    VerifiedAt: "",
  };
}

export const Employment = {
  encode(message: Employment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.EmployerName !== "") {
      writer.uint32(10).string(message.EmployerName);
    }
    if (message.JobTitle !== "") {
      writer.uint32(18).string(message.JobTitle);
    }
    if (message.StartDate !== undefined) {
      Timestamp.encode(toTimestamp(message.StartDate), writer.uint32(26).fork()).ldelim();
    }
    if (message.EndDate !== undefined) {
      Timestamp.encode(toTimestamp(message.EndDate), writer.uint32(34).fork()).ldelim();
    }
    if (message.Type !== 0) {
      writer.uint32(40).int32(message.Type);
    }
    if (message.Industry !== undefined) {
      writer.uint32(50).string(message.Industry);
    }
    if (message.Income !== undefined) {
      Income.encode(message.Income, writer.uint32(58).fork()).ldelim();
    }
    if (message.Contact !== undefined) {
      EmployerContact.encode(message.Contact, writer.uint32(66).fork()).ldelim();
    }
    if (message.IsVerified !== false) {
      writer.uint32(72).bool(message.IsVerified);
    }
    if (message.VerifiedAt !== "") {
      writer.uint32(82).string(message.VerifiedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Employment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.EmployerName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.JobTitle = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.StartDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.EndDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Industry = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.Income = Income.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.Contact = EmployerContact.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.IsVerified = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.VerifiedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Employment {
    return {
      EmployerName: isSet(object.EmployerName) ? globalThis.String(object.EmployerName) : "",
      JobTitle: isSet(object.JobTitle) ? globalThis.String(object.JobTitle) : "",
      StartDate: isSet(object.StartDate) ? fromJsonTimestamp(object.StartDate) : undefined,
      EndDate: isSet(object.EndDate) ? fromJsonTimestamp(object.EndDate) : undefined,
      Type: isSet(object.Type) ? employmentTypeFromJSON(object.Type) : 0,
      Industry: isSet(object.Industry) ? globalThis.String(object.Industry) : undefined,
      Income: isSet(object.Income) ? Income.fromJSON(object.Income) : undefined,
      Contact: isSet(object.Contact) ? EmployerContact.fromJSON(object.Contact) : undefined,
      IsVerified: isSet(object.IsVerified) ? globalThis.Boolean(object.IsVerified) : false,
      VerifiedAt: isSet(object.VerifiedAt) ? globalThis.String(object.VerifiedAt) : "",
    };
  },

  toJSON(message: Employment): unknown {
    const obj: any = {};
    if (message.EmployerName !== "") {
      obj.EmployerName = message.EmployerName;
    }
    if (message.JobTitle !== "") {
      obj.JobTitle = message.JobTitle;
    }
    if (message.StartDate !== undefined) {
      obj.StartDate = message.StartDate.toISOString();
    }
    if (message.EndDate !== undefined) {
      obj.EndDate = message.EndDate.toISOString();
    }
    if (message.Type !== 0) {
      obj.Type = employmentTypeToJSON(message.Type);
    }
    if (message.Industry !== undefined) {
      obj.Industry = message.Industry;
    }
    if (message.Income !== undefined) {
      obj.Income = Income.toJSON(message.Income);
    }
    if (message.Contact !== undefined) {
      obj.Contact = EmployerContact.toJSON(message.Contact);
    }
    if (message.IsVerified !== false) {
      obj.IsVerified = message.IsVerified;
    }
    if (message.VerifiedAt !== "") {
      obj.VerifiedAt = message.VerifiedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Employment>, I>>(base?: I): Employment {
    return Employment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Employment>, I>>(object: I): Employment {
    const message = createBaseEmployment();
    message.EmployerName = object.EmployerName ?? "";
    message.JobTitle = object.JobTitle ?? "";
    message.StartDate = object.StartDate ?? undefined;
    message.EndDate = object.EndDate ?? undefined;
    message.Type = object.Type ?? 0;
    message.Industry = object.Industry ?? undefined;
    message.Income = (object.Income !== undefined && object.Income !== null)
      ? Income.fromPartial(object.Income)
      : undefined;
    message.Contact = (object.Contact !== undefined && object.Contact !== null)
      ? EmployerContact.fromPartial(object.Contact)
      : undefined;
    message.IsVerified = object.IsVerified ?? false;
    message.VerifiedAt = object.VerifiedAt ?? "";
    return message;
  },
};

function createBaseIncome(): Income {
  return { Amount: 0, Currency: "", Frequency: 0 };
}

export const Income = {
  encode(message: Income, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Amount !== 0) {
      writer.uint32(13).float(message.Amount);
    }
    if (message.Currency !== "") {
      writer.uint32(18).string(message.Currency);
    }
    if (message.Frequency !== 0) {
      writer.uint32(24).int32(message.Frequency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Income {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncome();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.Amount = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Currency = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Frequency = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Income {
    return {
      Amount: isSet(object.Amount) ? globalThis.Number(object.Amount) : 0,
      Currency: isSet(object.Currency) ? globalThis.String(object.Currency) : "",
      Frequency: isSet(object.Frequency) ? incomeFrequencyFromJSON(object.Frequency) : 0,
    };
  },

  toJSON(message: Income): unknown {
    const obj: any = {};
    if (message.Amount !== 0) {
      obj.Amount = message.Amount;
    }
    if (message.Currency !== "") {
      obj.Currency = message.Currency;
    }
    if (message.Frequency !== 0) {
      obj.Frequency = incomeFrequencyToJSON(message.Frequency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Income>, I>>(base?: I): Income {
    return Income.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Income>, I>>(object: I): Income {
    const message = createBaseIncome();
    message.Amount = object.Amount ?? 0;
    message.Currency = object.Currency ?? "";
    message.Frequency = object.Frequency ?? 0;
    return message;
  },
};

function createBaseEmployerContact(): EmployerContact {
  return { Name: "", Email: "", Phone: "", Address: "" };
}

export const EmployerContact = {
  encode(message: EmployerContact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Name !== "") {
      writer.uint32(10).string(message.Name);
    }
    if (message.Email !== "") {
      writer.uint32(18).string(message.Email);
    }
    if (message.Phone !== "") {
      writer.uint32(26).string(message.Phone);
    }
    if (message.Address !== "") {
      writer.uint32(34).string(message.Address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EmployerContact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmployerContact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Phone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmployerContact {
    return {
      Name: isSet(object.Name) ? globalThis.String(object.Name) : "",
      Email: isSet(object.Email) ? globalThis.String(object.Email) : "",
      Phone: isSet(object.Phone) ? globalThis.String(object.Phone) : "",
      Address: isSet(object.Address) ? globalThis.String(object.Address) : "",
    };
  },

  toJSON(message: EmployerContact): unknown {
    const obj: any = {};
    if (message.Name !== "") {
      obj.Name = message.Name;
    }
    if (message.Email !== "") {
      obj.Email = message.Email;
    }
    if (message.Phone !== "") {
      obj.Phone = message.Phone;
    }
    if (message.Address !== "") {
      obj.Address = message.Address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmployerContact>, I>>(base?: I): EmployerContact {
    return EmployerContact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmployerContact>, I>>(object: I): EmployerContact {
    const message = createBaseEmployerContact();
    message.Name = object.Name ?? "";
    message.Email = object.Email ?? "";
    message.Phone = object.Phone ?? "";
    message.Address = object.Address ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return { User: undefined, MetaData: undefined, Audit: undefined };
}

export const User = {
  encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.User !== undefined) {
      UserDetails.encode(message.User, writer.uint32(10).fork()).ldelim();
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(18).fork()).ldelim();
    }
    if (message.Audit !== undefined) {
      Audit.encode(message.Audit, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.User = UserDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Audit = Audit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      User: isSet(object.User) ? UserDetails.fromJSON(object.User) : undefined,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      Audit: isSet(object.Audit) ? Audit.fromJSON(object.Audit) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.User !== undefined) {
      obj.User = UserDetails.toJSON(message.User);
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.Audit !== undefined) {
      obj.Audit = Audit.toJSON(message.Audit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.User = (object.User !== undefined && object.User !== null)
      ? UserDetails.fromPartial(object.User)
      : undefined;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.Audit = (object.Audit !== undefined && object.Audit !== null) ? Audit.fromPartial(object.Audit) : undefined;
    return message;
  },
};

function createBaseUserID(): UserID {
  return { UserID: "", OrganizationID: "", Network: undefined };
}

export const UserID = {
  encode(message: UserID, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.UserID !== "") {
      writer.uint32(10).string(message.UserID);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(18).string(message.OrganizationID);
    }
    if (message.Network !== undefined) {
      writer.uint32(24).int32(message.Network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserID {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Network = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserID {
    return {
      UserID: isSet(object.UserID) ? globalThis.String(object.UserID) : "",
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Network: isSet(object.Network) ? networkFromJSON(object.Network) : undefined,
    };
  },

  toJSON(message: UserID): unknown {
    const obj: any = {};
    if (message.UserID !== "") {
      obj.UserID = message.UserID;
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Network !== undefined) {
      obj.Network = networkToJSON(message.Network);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserID>, I>>(base?: I): UserID {
    return UserID.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserID>, I>>(object: I): UserID {
    const message = createBaseUserID();
    message.UserID = object.UserID ?? "";
    message.OrganizationID = object.OrganizationID ?? "";
    message.Network = object.Network ?? undefined;
    return message;
  },
};

function createBaseSocial(): Social {
  return { URL: "", Type: 0 };
}

export const Social = {
  encode(message: Social, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.URL !== "") {
      writer.uint32(10).string(message.URL);
    }
    if (message.Type !== 0) {
      writer.uint32(16).int32(message.Type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Social {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSocial();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.URL = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Social {
    return {
      URL: isSet(object.URL) ? globalThis.String(object.URL) : "",
      Type: isSet(object.Type) ? socialTypeFromJSON(object.Type) : 0,
    };
  },

  toJSON(message: Social): unknown {
    const obj: any = {};
    if (message.URL !== "") {
      obj.URL = message.URL;
    }
    if (message.Type !== 0) {
      obj.Type = socialTypeToJSON(message.Type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Social>, I>>(base?: I): Social {
    return Social.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Social>, I>>(object: I): Social {
    const message = createBaseSocial();
    message.URL = object.URL ?? "";
    message.Type = object.Type ?? 0;
    return message;
  },
};

function createBaseWallet(): Wallet {
  return { Address: "", Alias: "", Type: 0 };
}

export const Wallet = {
  encode(message: Wallet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Address !== "") {
      writer.uint32(10).string(message.Address);
    }
    if (message.Alias !== "") {
      writer.uint32(18).string(message.Alias);
    }
    if (message.Type !== 0) {
      writer.uint32(24).int32(message.Type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Wallet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Alias = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wallet {
    return {
      Address: isSet(object.Address) ? globalThis.String(object.Address) : "",
      Alias: isSet(object.Alias) ? globalThis.String(object.Alias) : "",
      Type: isSet(object.Type) ? walletTypeFromJSON(object.Type) : 0,
    };
  },

  toJSON(message: Wallet): unknown {
    const obj: any = {};
    if (message.Address !== "") {
      obj.Address = message.Address;
    }
    if (message.Alias !== "") {
      obj.Alias = message.Alias;
    }
    if (message.Type !== 0) {
      obj.Type = walletTypeToJSON(message.Type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wallet>, I>>(base?: I): Wallet {
    return Wallet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wallet>, I>>(object: I): Wallet {
    const message = createBaseWallet();
    message.Address = object.Address ?? "";
    message.Alias = object.Alias ?? "";
    message.Type = object.Type ?? 0;
    return message;
  },
};

function createBaseLanguage(): Language {
  return { UserID: "", Language: "", UserConfigured: false, Network: "" };
}

export const Language = {
  encode(message: Language, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.UserID !== "") {
      writer.uint32(10).string(message.UserID);
    }
    if (message.Language !== "") {
      writer.uint32(18).string(message.Language);
    }
    if (message.UserConfigured !== false) {
      writer.uint32(24).bool(message.UserConfigured);
    }
    if (message.Network !== "") {
      writer.uint32(34).string(message.Network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Language {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Language = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.UserConfigured = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Language {
    return {
      UserID: isSet(object.UserID) ? globalThis.String(object.UserID) : "",
      Language: isSet(object.Language) ? globalThis.String(object.Language) : "",
      UserConfigured: isSet(object.UserConfigured) ? globalThis.Boolean(object.UserConfigured) : false,
      Network: isSet(object.Network) ? globalThis.String(object.Network) : "",
    };
  },

  toJSON(message: Language): unknown {
    const obj: any = {};
    if (message.UserID !== "") {
      obj.UserID = message.UserID;
    }
    if (message.Language !== "") {
      obj.Language = message.Language;
    }
    if (message.UserConfigured !== false) {
      obj.UserConfigured = message.UserConfigured;
    }
    if (message.Network !== "") {
      obj.Network = message.Network;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Language>, I>>(base?: I): Language {
    return Language.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Language>, I>>(object: I): Language {
    const message = createBaseLanguage();
    message.UserID = object.UserID ?? "";
    message.Language = object.Language ?? "";
    message.UserConfigured = object.UserConfigured ?? false;
    message.Network = object.Network ?? "";
    return message;
  },
};

function createBaseUserList(): UserList {
  return { Users: [], Total: 0 };
}

export const UserList = {
  encode(message: UserList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Users) {
      User.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.Total !== 0) {
      writer.uint32(16).int32(message.Total);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Users.push(User.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Total = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserList {
    return {
      Users: globalThis.Array.isArray(object?.Users) ? object.Users.map((e: any) => User.fromJSON(e)) : [],
      Total: isSet(object.Total) ? globalThis.Number(object.Total) : 0,
    };
  },

  toJSON(message: UserList): unknown {
    const obj: any = {};
    if (message.Users?.length) {
      obj.Users = message.Users.map((e) => User.toJSON(e));
    }
    if (message.Total !== 0) {
      obj.Total = Math.round(message.Total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserList>, I>>(base?: I): UserList {
    return UserList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserList>, I>>(object: I): UserList {
    const message = createBaseUserList();
    message.Users = object.Users?.map((e) => User.fromPartial(e)) || [];
    message.Total = object.Total ?? 0;
    return message;
  },
};

function createBaseSetStatusMessage(): SetStatusMessage {
  return { UserID: "", OrganizationID: "", Status: 0, Network: undefined, Audit: undefined };
}

export const SetStatusMessage = {
  encode(message: SetStatusMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.UserID !== "") {
      writer.uint32(10).string(message.UserID);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(18).string(message.OrganizationID);
    }
    if (message.Status !== 0) {
      writer.uint32(24).int32(message.Status);
    }
    if (message.Network !== undefined) {
      writer.uint32(32).int32(message.Network);
    }
    if (message.Audit !== undefined) {
      Audit.encode(message.Audit, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetStatusMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetStatusMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.Network = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Audit = Audit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetStatusMessage {
    return {
      UserID: isSet(object.UserID) ? globalThis.String(object.UserID) : "",
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Status: isSet(object.Status) ? userStatusFromJSON(object.Status) : 0,
      Network: isSet(object.Network) ? networkFromJSON(object.Network) : undefined,
      Audit: isSet(object.Audit) ? Audit.fromJSON(object.Audit) : undefined,
    };
  },

  toJSON(message: SetStatusMessage): unknown {
    const obj: any = {};
    if (message.UserID !== "") {
      obj.UserID = message.UserID;
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Status !== 0) {
      obj.Status = userStatusToJSON(message.Status);
    }
    if (message.Network !== undefined) {
      obj.Network = networkToJSON(message.Network);
    }
    if (message.Audit !== undefined) {
      obj.Audit = Audit.toJSON(message.Audit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetStatusMessage>, I>>(base?: I): SetStatusMessage {
    return SetStatusMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetStatusMessage>, I>>(object: I): SetStatusMessage {
    const message = createBaseSetStatusMessage();
    message.UserID = object.UserID ?? "";
    message.OrganizationID = object.OrganizationID ?? "";
    message.Status = object.Status ?? 0;
    message.Network = object.Network ?? undefined;
    message.Audit = (object.Audit !== undefined && object.Audit !== null) ? Audit.fromPartial(object.Audit) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
