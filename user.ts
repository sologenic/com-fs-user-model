// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: user.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "./google/protobuf/timestamp";
import { UserDocumentCompliance } from "./sologenic/com-fs-document-model/document";
import { ClearingBroker, clearingBrokerFromJSON, clearingBrokerToJSON } from "./sologenic/com-fs-order-model/broker";
import { TradeProfileDetails, UserTradeProfile } from "./sologenic/com-fs-trade-profile-model/tradeprofile";
import { Audit } from "./sologenic/com-fs-utils-lib/models/audit/audit";
import { Lang, langFromJSON, langToJSON } from "./sologenic/com-fs-utils-lib/models/language/language";
import {
  MetaData,
  Network,
  networkFromJSON,
  networkToJSON,
} from "./sologenic/com-fs-utils-lib/models/metadata/metadata";
import { Role, roleFromJSON, roleToJSON } from "./sologenic/com-fs-utils-lib/models/role/role";

export const protobufPackage = "user";

export enum KYCStatus {
  /** KYC_STATUS_UNSPECIFIED - Default value, should not be used */
  KYC_STATUS_UNSPECIFIED = 0,
  /** KYC_STATUS_PENDING - Inquiry created but not completed */
  KYC_STATUS_PENDING = 1,
  /** KYC_STATUS_IN_REVIEW - Inquiry submitted but under manual review */
  KYC_STATUS_IN_REVIEW = 2,
  /** KYC_STATUS_APPROVED - Inquiry completed and approved */
  KYC_STATUS_APPROVED = 3,
  /** KYC_STATUS_REJECTED - Inquiry completed and explicitly rejected */
  KYC_STATUS_REJECTED = 4,
  /** KYC_STATUS_FAILED - Inquiry failed due to an error (e.g., document mismatch, bad image quality) */
  KYC_STATUS_FAILED = 5,
  /** KYC_STATUS_EXPIRED - Inquiry expired (e.g., not completed in time) */
  KYC_STATUS_EXPIRED = 6,
  UNRECOGNIZED = -1,
}

export function kYCStatusFromJSON(object: any): KYCStatus {
  switch (object) {
    case 0:
    case "KYC_STATUS_UNSPECIFIED":
      return KYCStatus.KYC_STATUS_UNSPECIFIED;
    case 1:
    case "KYC_STATUS_PENDING":
      return KYCStatus.KYC_STATUS_PENDING;
    case 2:
    case "KYC_STATUS_IN_REVIEW":
      return KYCStatus.KYC_STATUS_IN_REVIEW;
    case 3:
    case "KYC_STATUS_APPROVED":
      return KYCStatus.KYC_STATUS_APPROVED;
    case 4:
    case "KYC_STATUS_REJECTED":
      return KYCStatus.KYC_STATUS_REJECTED;
    case 5:
    case "KYC_STATUS_FAILED":
      return KYCStatus.KYC_STATUS_FAILED;
    case 6:
    case "KYC_STATUS_EXPIRED":
      return KYCStatus.KYC_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KYCStatus.UNRECOGNIZED;
  }
}

export function kYCStatusToJSON(object: KYCStatus): string {
  switch (object) {
    case KYCStatus.KYC_STATUS_UNSPECIFIED:
      return "KYC_STATUS_UNSPECIFIED";
    case KYCStatus.KYC_STATUS_PENDING:
      return "KYC_STATUS_PENDING";
    case KYCStatus.KYC_STATUS_IN_REVIEW:
      return "KYC_STATUS_IN_REVIEW";
    case KYCStatus.KYC_STATUS_APPROVED:
      return "KYC_STATUS_APPROVED";
    case KYCStatus.KYC_STATUS_REJECTED:
      return "KYC_STATUS_REJECTED";
    case KYCStatus.KYC_STATUS_FAILED:
      return "KYC_STATUS_FAILED";
    case KYCStatus.KYC_STATUS_EXPIRED:
      return "KYC_STATUS_EXPIRED";
    case KYCStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EmploymentType {
  NOT_USED_EMPLOYMENTTYPE = 0,
  FULL_TIME = 1,
  PART_TIME = 2,
  CONTRACT = 3,
  FREELANCE = 4,
  SELF_EMPLOYED = 5,
  INTERNSHIP = 6,
  UNRECOGNIZED = -1,
}

export function employmentTypeFromJSON(object: any): EmploymentType {
  switch (object) {
    case 0:
    case "NOT_USED_EMPLOYMENTTYPE":
      return EmploymentType.NOT_USED_EMPLOYMENTTYPE;
    case 1:
    case "FULL_TIME":
      return EmploymentType.FULL_TIME;
    case 2:
    case "PART_TIME":
      return EmploymentType.PART_TIME;
    case 3:
    case "CONTRACT":
      return EmploymentType.CONTRACT;
    case 4:
    case "FREELANCE":
      return EmploymentType.FREELANCE;
    case 5:
    case "SELF_EMPLOYED":
      return EmploymentType.SELF_EMPLOYED;
    case 6:
    case "INTERNSHIP":
      return EmploymentType.INTERNSHIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EmploymentType.UNRECOGNIZED;
  }
}

export function employmentTypeToJSON(object: EmploymentType): string {
  switch (object) {
    case EmploymentType.NOT_USED_EMPLOYMENTTYPE:
      return "NOT_USED_EMPLOYMENTTYPE";
    case EmploymentType.FULL_TIME:
      return "FULL_TIME";
    case EmploymentType.PART_TIME:
      return "PART_TIME";
    case EmploymentType.CONTRACT:
      return "CONTRACT";
    case EmploymentType.FREELANCE:
      return "FREELANCE";
    case EmploymentType.SELF_EMPLOYED:
      return "SELF_EMPLOYED";
    case EmploymentType.INTERNSHIP:
      return "INTERNSHIP";
    case EmploymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum IncomeFrequency {
  NOT_USED_INCOMEFREQUENCY = 0,
  HOURLY = 1,
  WEEKLY = 2,
  BI_WEEKLY = 3,
  MONTHLY = 4,
  ANNUALLY = 5,
  UNRECOGNIZED = -1,
}

export function incomeFrequencyFromJSON(object: any): IncomeFrequency {
  switch (object) {
    case 0:
    case "NOT_USED_INCOMEFREQUENCY":
      return IncomeFrequency.NOT_USED_INCOMEFREQUENCY;
    case 1:
    case "HOURLY":
      return IncomeFrequency.HOURLY;
    case 2:
    case "WEEKLY":
      return IncomeFrequency.WEEKLY;
    case 3:
    case "BI_WEEKLY":
      return IncomeFrequency.BI_WEEKLY;
    case 4:
    case "MONTHLY":
      return IncomeFrequency.MONTHLY;
    case 5:
    case "ANNUALLY":
      return IncomeFrequency.ANNUALLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IncomeFrequency.UNRECOGNIZED;
  }
}

export function incomeFrequencyToJSON(object: IncomeFrequency): string {
  switch (object) {
    case IncomeFrequency.NOT_USED_INCOMEFREQUENCY:
      return "NOT_USED_INCOMEFREQUENCY";
    case IncomeFrequency.HOURLY:
      return "HOURLY";
    case IncomeFrequency.WEEKLY:
      return "WEEKLY";
    case IncomeFrequency.BI_WEEKLY:
      return "BI_WEEKLY";
    case IncomeFrequency.MONTHLY:
      return "MONTHLY";
    case IncomeFrequency.ANNUALLY:
      return "ANNUALLY";
    case IncomeFrequency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SignerType {
  NOT_USER_SIGNETTYPE = 0,
  MOBILE_APP = 1,
  BROWSER_LEAP = 2,
  BROWSER_COSMOSTATION = 3,
  BROWSER_KEPLR = 4,
  UNRECOGNIZED = -1,
}

export function signerTypeFromJSON(object: any): SignerType {
  switch (object) {
    case 0:
    case "NOT_USER_SIGNETTYPE":
      return SignerType.NOT_USER_SIGNETTYPE;
    case 1:
    case "MOBILE_APP":
      return SignerType.MOBILE_APP;
    case 2:
    case "BROWSER_LEAP":
      return SignerType.BROWSER_LEAP;
    case 3:
    case "BROWSER_COSMOSTATION":
      return SignerType.BROWSER_COSMOSTATION;
    case 4:
    case "BROWSER_KEPLR":
      return SignerType.BROWSER_KEPLR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SignerType.UNRECOGNIZED;
  }
}

export function signerTypeToJSON(object: SignerType): string {
  switch (object) {
    case SignerType.NOT_USER_SIGNETTYPE:
      return "NOT_USER_SIGNETTYPE";
    case SignerType.MOBILE_APP:
      return "MOBILE_APP";
    case SignerType.BROWSER_LEAP:
      return "BROWSER_LEAP";
    case SignerType.BROWSER_COSMOSTATION:
      return "BROWSER_COSMOSTATION";
    case SignerType.BROWSER_KEPLR:
      return "BROWSER_KEPLR";
    case SignerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UserStatus {
  NOT_USED_USERSTATUS = 0,
  ACTIVE = 1,
  ADMIN_DEACTIVATED = 2,
  UNRECOGNIZED = -1,
}

export function userStatusFromJSON(object: any): UserStatus {
  switch (object) {
    case 0:
    case "NOT_USED_USERSTATUS":
      return UserStatus.NOT_USED_USERSTATUS;
    case 1:
    case "ACTIVE":
      return UserStatus.ACTIVE;
    case 2:
    case "ADMIN_DEACTIVATED":
      return UserStatus.ADMIN_DEACTIVATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserStatus.UNRECOGNIZED;
  }
}

export function userStatusToJSON(object: UserStatus): string {
  switch (object) {
    case UserStatus.NOT_USED_USERSTATUS:
      return "NOT_USED_USERSTATUS";
    case UserStatus.ACTIVE:
      return "ACTIVE";
    case UserStatus.ADMIN_DEACTIVATED:
      return "ADMIN_DEACTIVATED";
    case UserStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WalletType {
  NOT_USED_WALLETTYPE = 0,
  TFSA = 1,
  RRSP = 2,
  STANDARD = 3,
  UNRECOGNIZED = -1,
}

export function walletTypeFromJSON(object: any): WalletType {
  switch (object) {
    case 0:
    case "NOT_USED_WALLETTYPE":
      return WalletType.NOT_USED_WALLETTYPE;
    case 1:
    case "TFSA":
      return WalletType.TFSA;
    case 2:
    case "RRSP":
      return WalletType.RRSP;
    case 3:
    case "STANDARD":
      return WalletType.STANDARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WalletType.UNRECOGNIZED;
  }
}

export function walletTypeToJSON(object: WalletType): string {
  switch (object) {
    case WalletType.NOT_USED_WALLETTYPE:
      return "NOT_USED_WALLETTYPE";
    case WalletType.TFSA:
      return "TFSA";
    case WalletType.RRSP:
      return "RRSP";
    case WalletType.STANDARD:
      return "STANDARD";
    case WalletType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SocialType {
  NOT_USED_SOCIALTYPE = 0,
  WEBSITE = 1,
  GITHUB = 2,
  REDDIT = 3,
  DISCORD = 4,
  TWITTER = 5,
  FACEBOOK = 6,
  TELEGRAM = 7,
  INSTAGRAM = 8,
  LINKEDIN = 9,
  UNRECOGNIZED = -1,
}

export function socialTypeFromJSON(object: any): SocialType {
  switch (object) {
    case 0:
    case "NOT_USED_SOCIALTYPE":
      return SocialType.NOT_USED_SOCIALTYPE;
    case 1:
    case "WEBSITE":
      return SocialType.WEBSITE;
    case 2:
    case "GITHUB":
      return SocialType.GITHUB;
    case 3:
    case "REDDIT":
      return SocialType.REDDIT;
    case 4:
    case "DISCORD":
      return SocialType.DISCORD;
    case 5:
    case "TWITTER":
      return SocialType.TWITTER;
    case 6:
    case "FACEBOOK":
      return SocialType.FACEBOOK;
    case 7:
    case "TELEGRAM":
      return SocialType.TELEGRAM;
    case 8:
    case "INSTAGRAM":
      return SocialType.INSTAGRAM;
    case 9:
    case "LINKEDIN":
      return SocialType.LINKEDIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SocialType.UNRECOGNIZED;
  }
}

export function socialTypeToJSON(object: SocialType): string {
  switch (object) {
    case SocialType.NOT_USED_SOCIALTYPE:
      return "NOT_USED_SOCIALTYPE";
    case SocialType.WEBSITE:
      return "WEBSITE";
    case SocialType.GITHUB:
      return "GITHUB";
    case SocialType.REDDIT:
      return "REDDIT";
    case SocialType.DISCORD:
      return "DISCORD";
    case SocialType.TWITTER:
      return "TWITTER";
    case SocialType.FACEBOOK:
      return "FACEBOOK";
    case SocialType.TELEGRAM:
      return "TELEGRAM";
    case SocialType.INSTAGRAM:
      return "INSTAGRAM";
    case SocialType.LINKEDIN:
      return "LINKEDIN";
    case SocialType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LiquidationImportance {
  VERY_IMPORTANT = 0,
  SOMEWHAT_IMPORTANT = 1,
  NOT_IMPORTANT = 2,
  NO_PREFERENCE = 3,
  UNRECOGNIZED = -1,
}

export function liquidationImportanceFromJSON(object: any): LiquidationImportance {
  switch (object) {
    case 0:
    case "VERY_IMPORTANT":
      return LiquidationImportance.VERY_IMPORTANT;
    case 1:
    case "SOMEWHAT_IMPORTANT":
      return LiquidationImportance.SOMEWHAT_IMPORTANT;
    case 2:
    case "NOT_IMPORTANT":
      return LiquidationImportance.NOT_IMPORTANT;
    case 3:
    case "NO_PREFERENCE":
      return LiquidationImportance.NO_PREFERENCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LiquidationImportance.UNRECOGNIZED;
  }
}

export function liquidationImportanceToJSON(object: LiquidationImportance): string {
  switch (object) {
    case LiquidationImportance.VERY_IMPORTANT:
      return "VERY_IMPORTANT";
    case LiquidationImportance.SOMEWHAT_IMPORTANT:
      return "SOMEWHAT_IMPORTANT";
    case LiquidationImportance.NOT_IMPORTANT:
      return "NOT_IMPORTANT";
    case LiquidationImportance.NO_PREFERENCE:
      return "NO_PREFERENCE";
    case LiquidationImportance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RiskTolerance {
  CONSERVATIVE = 0,
  MODERATELY_CONSERVATIVE = 1,
  MODERATE = 2,
  MODERATELY_AGGRESSIVE = 3,
  SIGNIFICANT_RISK = 4,
  UNRECOGNIZED = -1,
}

export function riskToleranceFromJSON(object: any): RiskTolerance {
  switch (object) {
    case 0:
    case "CONSERVATIVE":
      return RiskTolerance.CONSERVATIVE;
    case 1:
    case "MODERATELY_CONSERVATIVE":
      return RiskTolerance.MODERATELY_CONSERVATIVE;
    case 2:
    case "MODERATE":
      return RiskTolerance.MODERATE;
    case 3:
    case "MODERATELY_AGGRESSIVE":
      return RiskTolerance.MODERATELY_AGGRESSIVE;
    case 4:
    case "SIGNIFICANT_RISK":
      return RiskTolerance.SIGNIFICANT_RISK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RiskTolerance.UNRECOGNIZED;
  }
}

export function riskToleranceToJSON(object: RiskTolerance): string {
  switch (object) {
    case RiskTolerance.CONSERVATIVE:
      return "CONSERVATIVE";
    case RiskTolerance.MODERATELY_CONSERVATIVE:
      return "MODERATELY_CONSERVATIVE";
    case RiskTolerance.MODERATE:
      return "MODERATE";
    case RiskTolerance.MODERATELY_AGGRESSIVE:
      return "MODERATELY_AGGRESSIVE";
    case RiskTolerance.SIGNIFICANT_RISK:
      return "SIGNIFICANT_RISK";
    case RiskTolerance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum InvestmentObjective {
  INCOME = 0,
  BALANCED = 1,
  GROWTH_AND_INCOME = 2,
  SAFE_LONG_TERM_GROWTH = 3,
  GREATER_RISK_LONG_TERM_GROWTH = 4,
  SPECULATION = 5,
  UNRECOGNIZED = -1,
}

export function investmentObjectiveFromJSON(object: any): InvestmentObjective {
  switch (object) {
    case 0:
    case "INCOME":
      return InvestmentObjective.INCOME;
    case 1:
    case "BALANCED":
      return InvestmentObjective.BALANCED;
    case 2:
    case "GROWTH_AND_INCOME":
      return InvestmentObjective.GROWTH_AND_INCOME;
    case 3:
    case "SAFE_LONG_TERM_GROWTH":
      return InvestmentObjective.SAFE_LONG_TERM_GROWTH;
    case 4:
    case "GREATER_RISK_LONG_TERM_GROWTH":
      return InvestmentObjective.GREATER_RISK_LONG_TERM_GROWTH;
    case 5:
    case "SPECULATION":
      return InvestmentObjective.SPECULATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InvestmentObjective.UNRECOGNIZED;
  }
}

export function investmentObjectiveToJSON(object: InvestmentObjective): string {
  switch (object) {
    case InvestmentObjective.INCOME:
      return "INCOME";
    case InvestmentObjective.BALANCED:
      return "BALANCED";
    case InvestmentObjective.GROWTH_AND_INCOME:
      return "GROWTH_AND_INCOME";
    case InvestmentObjective.SAFE_LONG_TERM_GROWTH:
      return "SAFE_LONG_TERM_GROWTH";
    case InvestmentObjective.GREATER_RISK_LONG_TERM_GROWTH:
      return "GREATER_RISK_LONG_TERM_GROWTH";
    case InvestmentObjective.SPECULATION:
      return "SPECULATION";
    case InvestmentObjective.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface IDNumber {
  IssuingCountry: string;
  IdentificationClass: string;
  IdentificationNumber: string;
}

export interface UserKYCDetails {
  Birthdate: string;
  PhoneNumber: string;
  EmailAddress: string;
  AddressStreet1: string;
  AddressStreet2: string;
  AddressCity: string;
  AddressSubdivision: string;
  AddressPostalCode: string;
  CountryCode: string;
  SocialSecurityNumber: string;
  IdentificationNumber: string;
  FirstName: string;
  LastName: string;
}

export interface UserDetails {
  /** email address used for firebase authentication */
  UserID: string;
  FirstName: string;
  LastName: string;
  Address: string;
  Avatar: string;
  /** "Nickname" */
  Alias: string;
  Description: string;
  Status: UserStatus;
  Wallets: Wallet[];
  Socials: Social[];
  Language: Lang;
  /** UUID for the external user identifier in the KYC provider */
  ExternalUserID: string;
  /** UUID */
  OrganizationID: string;
  Employment?:
    | Employment
    | undefined;
  /** A retail user will always have a role of "NORMAL_USER" */
  Role: Role;
  /** Trade profile details */
  TradeProfile:
    | TradeProfileDetails
    | undefined;
  /** Array of inquiry ID's */
  KYCInquiries: string[];
  KYCDetails: UserKYCDetails | undefined;
  UserDocumentCompliance:
    | UserDocumentCompliance
    | undefined;
  /** Status of KYC verification, e.g., PENDING, APPROVED, REJECTED */
  KYCStatus: KYCStatus;
  UserTradeProfile: UserTradeProfile | undefined;
  ComplianceQuestions: ComplianceQuestions[];
  BrokerAccounts: BrokerAccount[];
  BankAccounts: BankAccount[];
}

/** TODO: to be verified when more information is available */
export interface Employment {
  EmployerName: string;
  JobTitle: string;
  StartDate:
    | Date
    | undefined;
  /** Empty if still employed */
  EndDate: Date | undefined;
  Type: EmploymentType;
  Industry?: string | undefined;
  Income: Income | undefined;
  Contact: EmployerContact | undefined;
  IsVerified: boolean;
  VerifiedAt: string;
}

export interface Income {
  Amount: number;
  Currency: string;
  Frequency: IncomeFrequency;
}

export interface EmployerContact {
  Name: string;
  Email: string;
  Phone: string;
  Address: string;
}

export interface User {
  User: UserDetails | undefined;
  MetaData: MetaData | undefined;
  Audit: Audit | undefined;
}

export interface UserID {
  UserID: string;
  OrganizationID: string;
  Network?: Network | undefined;
}

export interface Social {
  URL: string;
  Type: SocialType;
}

export interface Wallet {
  Address: string;
  Alias: string;
  Type: WalletType;
  SignerType: SignerType;
}

export interface UserList {
  Users: User[];
  Offset?: number | undefined;
}

export interface StatusMessage {
  UserID: string;
  OrganizationID: string;
  Status: UserStatus;
  Network?: Network | undefined;
  Audit: Audit | undefined;
}

export interface Filter {
  UserIDs: string[];
  Network?: Network | undefined;
  OrganizationID: string;
  Offset?: number | undefined;
  Limit?: number | undefined;
  InquiryID?: string | undefined;
  Status?: UserStatus | undefined;
  ExternalUserIDs: string[];
  WalletAddress?: string | undefined;
}

/** This model is open to having multiple questionaires with regards to compliance like MiFID, etc. */
export interface ComplianceQuestions {
  USA?: USA | undefined;
}

export interface USA {
  RecordedAt: Date | undefined;
  YearsExperience: number;
  AnnualIncome: number;
  NetWorth: number;
  ConversionImportance: LiquidationImportance;
  Tolerance: RiskTolerance;
  Objective: InvestmentObjective;
}

export interface BankAccount {
  AccountName: string;
  /** user's identifier in the bank account */
  BankName: string;
  /** bank address */
  BankAddress: string;
  /** bank account number */
  AccountNumber: string;
  /** bank routing number */
  ABA: string;
  SWIFT: string;
  IBAN: string;
}

export interface BrokerAccount {
  /** user's identifier in the broker account */
  AccountID: string;
  /** "RQD", etc. */
  Broker: ClearingBroker;
  /** broker identifier */
  OrganizationID: string;
  /** bank account profiles for the broker account */
  Profiles: string[];
}

function createBaseIDNumber(): IDNumber {
  return { IssuingCountry: "", IdentificationClass: "", IdentificationNumber: "" };
}

export const IDNumber = {
  encode(message: IDNumber, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.IssuingCountry !== "") {
      writer.uint32(10).string(message.IssuingCountry);
    }
    if (message.IdentificationClass !== "") {
      writer.uint32(18).string(message.IdentificationClass);
    }
    if (message.IdentificationNumber !== "") {
      writer.uint32(26).string(message.IdentificationNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IDNumber {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIDNumber();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.IssuingCountry = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.IdentificationClass = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.IdentificationNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IDNumber {
    return {
      IssuingCountry: isSet(object.IssuingCountry) ? globalThis.String(object.IssuingCountry) : "",
      IdentificationClass: isSet(object.IdentificationClass) ? globalThis.String(object.IdentificationClass) : "",
      IdentificationNumber: isSet(object.IdentificationNumber) ? globalThis.String(object.IdentificationNumber) : "",
    };
  },

  toJSON(message: IDNumber): unknown {
    const obj: any = {};
    if (message.IssuingCountry !== "") {
      obj.IssuingCountry = message.IssuingCountry;
    }
    if (message.IdentificationClass !== "") {
      obj.IdentificationClass = message.IdentificationClass;
    }
    if (message.IdentificationNumber !== "") {
      obj.IdentificationNumber = message.IdentificationNumber;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IDNumber>, I>>(base?: I): IDNumber {
    return IDNumber.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IDNumber>, I>>(object: I): IDNumber {
    const message = createBaseIDNumber();
    message.IssuingCountry = object.IssuingCountry ?? "";
    message.IdentificationClass = object.IdentificationClass ?? "";
    message.IdentificationNumber = object.IdentificationNumber ?? "";
    return message;
  },
};

function createBaseUserKYCDetails(): UserKYCDetails {
  return {
    Birthdate: "",
    PhoneNumber: "",
    EmailAddress: "",
    AddressStreet1: "",
    AddressStreet2: "",
    AddressCity: "",
    AddressSubdivision: "",
    AddressPostalCode: "",
    CountryCode: "",
    SocialSecurityNumber: "",
    IdentificationNumber: "",
    FirstName: "",
    LastName: "",
  };
}

export const UserKYCDetails = {
  encode(message: UserKYCDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Birthdate !== "") {
      writer.uint32(10).string(message.Birthdate);
    }
    if (message.PhoneNumber !== "") {
      writer.uint32(18).string(message.PhoneNumber);
    }
    if (message.EmailAddress !== "") {
      writer.uint32(26).string(message.EmailAddress);
    }
    if (message.AddressStreet1 !== "") {
      writer.uint32(34).string(message.AddressStreet1);
    }
    if (message.AddressStreet2 !== "") {
      writer.uint32(42).string(message.AddressStreet2);
    }
    if (message.AddressCity !== "") {
      writer.uint32(50).string(message.AddressCity);
    }
    if (message.AddressSubdivision !== "") {
      writer.uint32(58).string(message.AddressSubdivision);
    }
    if (message.AddressPostalCode !== "") {
      writer.uint32(66).string(message.AddressPostalCode);
    }
    if (message.CountryCode !== "") {
      writer.uint32(74).string(message.CountryCode);
    }
    if (message.SocialSecurityNumber !== "") {
      writer.uint32(82).string(message.SocialSecurityNumber);
    }
    if (message.IdentificationNumber !== "") {
      writer.uint32(90).string(message.IdentificationNumber);
    }
    if (message.FirstName !== "") {
      writer.uint32(98).string(message.FirstName);
    }
    if (message.LastName !== "") {
      writer.uint32(106).string(message.LastName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserKYCDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserKYCDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Birthdate = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.PhoneNumber = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.EmailAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.AddressStreet1 = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.AddressStreet2 = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.AddressCity = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.AddressSubdivision = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.AddressPostalCode = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.CountryCode = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.SocialSecurityNumber = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.IdentificationNumber = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.FirstName = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.LastName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserKYCDetails {
    return {
      Birthdate: isSet(object.Birthdate) ? globalThis.String(object.Birthdate) : "",
      PhoneNumber: isSet(object.PhoneNumber) ? globalThis.String(object.PhoneNumber) : "",
      EmailAddress: isSet(object.EmailAddress) ? globalThis.String(object.EmailAddress) : "",
      AddressStreet1: isSet(object.AddressStreet1) ? globalThis.String(object.AddressStreet1) : "",
      AddressStreet2: isSet(object.AddressStreet2) ? globalThis.String(object.AddressStreet2) : "",
      AddressCity: isSet(object.AddressCity) ? globalThis.String(object.AddressCity) : "",
      AddressSubdivision: isSet(object.AddressSubdivision) ? globalThis.String(object.AddressSubdivision) : "",
      AddressPostalCode: isSet(object.AddressPostalCode) ? globalThis.String(object.AddressPostalCode) : "",
      CountryCode: isSet(object.CountryCode) ? globalThis.String(object.CountryCode) : "",
      SocialSecurityNumber: isSet(object.SocialSecurityNumber) ? globalThis.String(object.SocialSecurityNumber) : "",
      IdentificationNumber: isSet(object.IdentificationNumber) ? globalThis.String(object.IdentificationNumber) : "",
      FirstName: isSet(object.FirstName) ? globalThis.String(object.FirstName) : "",
      LastName: isSet(object.LastName) ? globalThis.String(object.LastName) : "",
    };
  },

  toJSON(message: UserKYCDetails): unknown {
    const obj: any = {};
    if (message.Birthdate !== "") {
      obj.Birthdate = message.Birthdate;
    }
    if (message.PhoneNumber !== "") {
      obj.PhoneNumber = message.PhoneNumber;
    }
    if (message.EmailAddress !== "") {
      obj.EmailAddress = message.EmailAddress;
    }
    if (message.AddressStreet1 !== "") {
      obj.AddressStreet1 = message.AddressStreet1;
    }
    if (message.AddressStreet2 !== "") {
      obj.AddressStreet2 = message.AddressStreet2;
    }
    if (message.AddressCity !== "") {
      obj.AddressCity = message.AddressCity;
    }
    if (message.AddressSubdivision !== "") {
      obj.AddressSubdivision = message.AddressSubdivision;
    }
    if (message.AddressPostalCode !== "") {
      obj.AddressPostalCode = message.AddressPostalCode;
    }
    if (message.CountryCode !== "") {
      obj.CountryCode = message.CountryCode;
    }
    if (message.SocialSecurityNumber !== "") {
      obj.SocialSecurityNumber = message.SocialSecurityNumber;
    }
    if (message.IdentificationNumber !== "") {
      obj.IdentificationNumber = message.IdentificationNumber;
    }
    if (message.FirstName !== "") {
      obj.FirstName = message.FirstName;
    }
    if (message.LastName !== "") {
      obj.LastName = message.LastName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserKYCDetails>, I>>(base?: I): UserKYCDetails {
    return UserKYCDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserKYCDetails>, I>>(object: I): UserKYCDetails {
    const message = createBaseUserKYCDetails();
    message.Birthdate = object.Birthdate ?? "";
    message.PhoneNumber = object.PhoneNumber ?? "";
    message.EmailAddress = object.EmailAddress ?? "";
    message.AddressStreet1 = object.AddressStreet1 ?? "";
    message.AddressStreet2 = object.AddressStreet2 ?? "";
    message.AddressCity = object.AddressCity ?? "";
    message.AddressSubdivision = object.AddressSubdivision ?? "";
    message.AddressPostalCode = object.AddressPostalCode ?? "";
    message.CountryCode = object.CountryCode ?? "";
    message.SocialSecurityNumber = object.SocialSecurityNumber ?? "";
    message.IdentificationNumber = object.IdentificationNumber ?? "";
    message.FirstName = object.FirstName ?? "";
    message.LastName = object.LastName ?? "";
    return message;
  },
};

function createBaseUserDetails(): UserDetails {
  return {
    UserID: "",
    FirstName: "",
    LastName: "",
    Address: "",
    Avatar: "",
    Alias: "",
    Description: "",
    Status: 0,
    Wallets: [],
    Socials: [],
    Language: 0,
    ExternalUserID: "",
    OrganizationID: "",
    Employment: undefined,
    Role: 0,
    TradeProfile: undefined,
    KYCInquiries: [],
    KYCDetails: undefined,
    UserDocumentCompliance: undefined,
    KYCStatus: 0,
    UserTradeProfile: undefined,
    ComplianceQuestions: [],
    BrokerAccounts: [],
    BankAccounts: [],
  };
}

export const UserDetails = {
  encode(message: UserDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.UserID !== "") {
      writer.uint32(10).string(message.UserID);
    }
    if (message.FirstName !== "") {
      writer.uint32(18).string(message.FirstName);
    }
    if (message.LastName !== "") {
      writer.uint32(26).string(message.LastName);
    }
    if (message.Address !== "") {
      writer.uint32(34).string(message.Address);
    }
    if (message.Avatar !== "") {
      writer.uint32(42).string(message.Avatar);
    }
    if (message.Alias !== "") {
      writer.uint32(50).string(message.Alias);
    }
    if (message.Description !== "") {
      writer.uint32(58).string(message.Description);
    }
    if (message.Status !== 0) {
      writer.uint32(64).int32(message.Status);
    }
    for (const v of message.Wallets) {
      Wallet.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.Socials) {
      Social.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    if (message.Language !== 0) {
      writer.uint32(88).int32(message.Language);
    }
    if (message.ExternalUserID !== "") {
      writer.uint32(98).string(message.ExternalUserID);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(106).string(message.OrganizationID);
    }
    if (message.Employment !== undefined) {
      Employment.encode(message.Employment, writer.uint32(114).fork()).ldelim();
    }
    if (message.Role !== 0) {
      writer.uint32(120).int32(message.Role);
    }
    if (message.TradeProfile !== undefined) {
      TradeProfileDetails.encode(message.TradeProfile, writer.uint32(130).fork()).ldelim();
    }
    for (const v of message.KYCInquiries) {
      writer.uint32(138).string(v!);
    }
    if (message.KYCDetails !== undefined) {
      UserKYCDetails.encode(message.KYCDetails, writer.uint32(146).fork()).ldelim();
    }
    if (message.UserDocumentCompliance !== undefined) {
      UserDocumentCompliance.encode(message.UserDocumentCompliance, writer.uint32(154).fork()).ldelim();
    }
    if (message.KYCStatus !== 0) {
      writer.uint32(160).int32(message.KYCStatus);
    }
    if (message.UserTradeProfile !== undefined) {
      UserTradeProfile.encode(message.UserTradeProfile, writer.uint32(170).fork()).ldelim();
    }
    for (const v of message.ComplianceQuestions) {
      ComplianceQuestions.encode(v!, writer.uint32(178).fork()).ldelim();
    }
    for (const v of message.BrokerAccounts) {
      BrokerAccount.encode(v!, writer.uint32(186).fork()).ldelim();
    }
    for (const v of message.BankAccounts) {
      BankAccount.encode(v!, writer.uint32(194).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.FirstName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.LastName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Address = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Avatar = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Alias = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.Description = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.Wallets.push(Wallet.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.Socials.push(Social.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.Language = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.ExternalUserID = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.Employment = Employment.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.Role = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.TradeProfile = TradeProfileDetails.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.KYCInquiries.push(reader.string());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.KYCDetails = UserKYCDetails.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.UserDocumentCompliance = UserDocumentCompliance.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.KYCStatus = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.UserTradeProfile = UserTradeProfile.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.ComplianceQuestions.push(ComplianceQuestions.decode(reader, reader.uint32()));
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.BrokerAccounts.push(BrokerAccount.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.BankAccounts.push(BankAccount.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDetails {
    return {
      UserID: isSet(object.UserID) ? globalThis.String(object.UserID) : "",
      FirstName: isSet(object.FirstName) ? globalThis.String(object.FirstName) : "",
      LastName: isSet(object.LastName) ? globalThis.String(object.LastName) : "",
      Address: isSet(object.Address) ? globalThis.String(object.Address) : "",
      Avatar: isSet(object.Avatar) ? globalThis.String(object.Avatar) : "",
      Alias: isSet(object.Alias) ? globalThis.String(object.Alias) : "",
      Description: isSet(object.Description) ? globalThis.String(object.Description) : "",
      Status: isSet(object.Status) ? userStatusFromJSON(object.Status) : 0,
      Wallets: globalThis.Array.isArray(object?.Wallets) ? object.Wallets.map((e: any) => Wallet.fromJSON(e)) : [],
      Socials: globalThis.Array.isArray(object?.Socials) ? object.Socials.map((e: any) => Social.fromJSON(e)) : [],
      Language: isSet(object.Language) ? langFromJSON(object.Language) : 0,
      ExternalUserID: isSet(object.ExternalUserID) ? globalThis.String(object.ExternalUserID) : "",
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Employment: isSet(object.Employment) ? Employment.fromJSON(object.Employment) : undefined,
      Role: isSet(object.Role) ? roleFromJSON(object.Role) : 0,
      TradeProfile: isSet(object.TradeProfile) ? TradeProfileDetails.fromJSON(object.TradeProfile) : undefined,
      KYCInquiries: globalThis.Array.isArray(object?.KYCInquiries)
        ? object.KYCInquiries.map((e: any) => globalThis.String(e))
        : [],
      KYCDetails: isSet(object.KYCDetails) ? UserKYCDetails.fromJSON(object.KYCDetails) : undefined,
      UserDocumentCompliance: isSet(object.UserDocumentCompliance)
        ? UserDocumentCompliance.fromJSON(object.UserDocumentCompliance)
        : undefined,
      KYCStatus: isSet(object.KYCStatus) ? kYCStatusFromJSON(object.KYCStatus) : 0,
      UserTradeProfile: isSet(object.UserTradeProfile) ? UserTradeProfile.fromJSON(object.UserTradeProfile) : undefined,
      ComplianceQuestions: globalThis.Array.isArray(object?.ComplianceQuestions)
        ? object.ComplianceQuestions.map((e: any) => ComplianceQuestions.fromJSON(e))
        : [],
      BrokerAccounts: globalThis.Array.isArray(object?.BrokerAccounts)
        ? object.BrokerAccounts.map((e: any) => BrokerAccount.fromJSON(e))
        : [],
      BankAccounts: globalThis.Array.isArray(object?.BankAccounts)
        ? object.BankAccounts.map((e: any) => BankAccount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserDetails): unknown {
    const obj: any = {};
    if (message.UserID !== "") {
      obj.UserID = message.UserID;
    }
    if (message.FirstName !== "") {
      obj.FirstName = message.FirstName;
    }
    if (message.LastName !== "") {
      obj.LastName = message.LastName;
    }
    if (message.Address !== "") {
      obj.Address = message.Address;
    }
    if (message.Avatar !== "") {
      obj.Avatar = message.Avatar;
    }
    if (message.Alias !== "") {
      obj.Alias = message.Alias;
    }
    if (message.Description !== "") {
      obj.Description = message.Description;
    }
    if (message.Status !== 0) {
      obj.Status = userStatusToJSON(message.Status);
    }
    if (message.Wallets?.length) {
      obj.Wallets = message.Wallets.map((e) => Wallet.toJSON(e));
    }
    if (message.Socials?.length) {
      obj.Socials = message.Socials.map((e) => Social.toJSON(e));
    }
    if (message.Language !== 0) {
      obj.Language = langToJSON(message.Language);
    }
    if (message.ExternalUserID !== "") {
      obj.ExternalUserID = message.ExternalUserID;
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Employment !== undefined) {
      obj.Employment = Employment.toJSON(message.Employment);
    }
    if (message.Role !== 0) {
      obj.Role = roleToJSON(message.Role);
    }
    if (message.TradeProfile !== undefined) {
      obj.TradeProfile = TradeProfileDetails.toJSON(message.TradeProfile);
    }
    if (message.KYCInquiries?.length) {
      obj.KYCInquiries = message.KYCInquiries;
    }
    if (message.KYCDetails !== undefined) {
      obj.KYCDetails = UserKYCDetails.toJSON(message.KYCDetails);
    }
    if (message.UserDocumentCompliance !== undefined) {
      obj.UserDocumentCompliance = UserDocumentCompliance.toJSON(message.UserDocumentCompliance);
    }
    if (message.KYCStatus !== 0) {
      obj.KYCStatus = kYCStatusToJSON(message.KYCStatus);
    }
    if (message.UserTradeProfile !== undefined) {
      obj.UserTradeProfile = UserTradeProfile.toJSON(message.UserTradeProfile);
    }
    if (message.ComplianceQuestions?.length) {
      obj.ComplianceQuestions = message.ComplianceQuestions.map((e) => ComplianceQuestions.toJSON(e));
    }
    if (message.BrokerAccounts?.length) {
      obj.BrokerAccounts = message.BrokerAccounts.map((e) => BrokerAccount.toJSON(e));
    }
    if (message.BankAccounts?.length) {
      obj.BankAccounts = message.BankAccounts.map((e) => BankAccount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserDetails>, I>>(base?: I): UserDetails {
    return UserDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserDetails>, I>>(object: I): UserDetails {
    const message = createBaseUserDetails();
    message.UserID = object.UserID ?? "";
    message.FirstName = object.FirstName ?? "";
    message.LastName = object.LastName ?? "";
    message.Address = object.Address ?? "";
    message.Avatar = object.Avatar ?? "";
    message.Alias = object.Alias ?? "";
    message.Description = object.Description ?? "";
    message.Status = object.Status ?? 0;
    message.Wallets = object.Wallets?.map((e) => Wallet.fromPartial(e)) || [];
    message.Socials = object.Socials?.map((e) => Social.fromPartial(e)) || [];
    message.Language = object.Language ?? 0;
    message.ExternalUserID = object.ExternalUserID ?? "";
    message.OrganizationID = object.OrganizationID ?? "";
    message.Employment = (object.Employment !== undefined && object.Employment !== null)
      ? Employment.fromPartial(object.Employment)
      : undefined;
    message.Role = object.Role ?? 0;
    message.TradeProfile = (object.TradeProfile !== undefined && object.TradeProfile !== null)
      ? TradeProfileDetails.fromPartial(object.TradeProfile)
      : undefined;
    message.KYCInquiries = object.KYCInquiries?.map((e) => e) || [];
    message.KYCDetails = (object.KYCDetails !== undefined && object.KYCDetails !== null)
      ? UserKYCDetails.fromPartial(object.KYCDetails)
      : undefined;
    message.UserDocumentCompliance =
      (object.UserDocumentCompliance !== undefined && object.UserDocumentCompliance !== null)
        ? UserDocumentCompliance.fromPartial(object.UserDocumentCompliance)
        : undefined;
    message.KYCStatus = object.KYCStatus ?? 0;
    message.UserTradeProfile = (object.UserTradeProfile !== undefined && object.UserTradeProfile !== null)
      ? UserTradeProfile.fromPartial(object.UserTradeProfile)
      : undefined;
    message.ComplianceQuestions = object.ComplianceQuestions?.map((e) => ComplianceQuestions.fromPartial(e)) || [];
    message.BrokerAccounts = object.BrokerAccounts?.map((e) => BrokerAccount.fromPartial(e)) || [];
    message.BankAccounts = object.BankAccounts?.map((e) => BankAccount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEmployment(): Employment {
  return {
    EmployerName: "",
    JobTitle: "",
    StartDate: undefined,
    EndDate: undefined,
    Type: 0,
    Industry: undefined,
    Income: undefined,
    Contact: undefined,
    IsVerified: false,
    VerifiedAt: "",
  };
}

export const Employment = {
  encode(message: Employment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.EmployerName !== "") {
      writer.uint32(10).string(message.EmployerName);
    }
    if (message.JobTitle !== "") {
      writer.uint32(18).string(message.JobTitle);
    }
    if (message.StartDate !== undefined) {
      Timestamp.encode(toTimestamp(message.StartDate), writer.uint32(26).fork()).ldelim();
    }
    if (message.EndDate !== undefined) {
      Timestamp.encode(toTimestamp(message.EndDate), writer.uint32(34).fork()).ldelim();
    }
    if (message.Type !== 0) {
      writer.uint32(40).int32(message.Type);
    }
    if (message.Industry !== undefined) {
      writer.uint32(50).string(message.Industry);
    }
    if (message.Income !== undefined) {
      Income.encode(message.Income, writer.uint32(58).fork()).ldelim();
    }
    if (message.Contact !== undefined) {
      EmployerContact.encode(message.Contact, writer.uint32(66).fork()).ldelim();
    }
    if (message.IsVerified !== false) {
      writer.uint32(72).bool(message.IsVerified);
    }
    if (message.VerifiedAt !== "") {
      writer.uint32(82).string(message.VerifiedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Employment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.EmployerName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.JobTitle = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.StartDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.EndDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Industry = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.Income = Income.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.Contact = EmployerContact.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.IsVerified = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.VerifiedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Employment {
    return {
      EmployerName: isSet(object.EmployerName) ? globalThis.String(object.EmployerName) : "",
      JobTitle: isSet(object.JobTitle) ? globalThis.String(object.JobTitle) : "",
      StartDate: isSet(object.StartDate) ? fromJsonTimestamp(object.StartDate) : undefined,
      EndDate: isSet(object.EndDate) ? fromJsonTimestamp(object.EndDate) : undefined,
      Type: isSet(object.Type) ? employmentTypeFromJSON(object.Type) : 0,
      Industry: isSet(object.Industry) ? globalThis.String(object.Industry) : undefined,
      Income: isSet(object.Income) ? Income.fromJSON(object.Income) : undefined,
      Contact: isSet(object.Contact) ? EmployerContact.fromJSON(object.Contact) : undefined,
      IsVerified: isSet(object.IsVerified) ? globalThis.Boolean(object.IsVerified) : false,
      VerifiedAt: isSet(object.VerifiedAt) ? globalThis.String(object.VerifiedAt) : "",
    };
  },

  toJSON(message: Employment): unknown {
    const obj: any = {};
    if (message.EmployerName !== "") {
      obj.EmployerName = message.EmployerName;
    }
    if (message.JobTitle !== "") {
      obj.JobTitle = message.JobTitle;
    }
    if (message.StartDate !== undefined) {
      obj.StartDate = message.StartDate.toISOString();
    }
    if (message.EndDate !== undefined) {
      obj.EndDate = message.EndDate.toISOString();
    }
    if (message.Type !== 0) {
      obj.Type = employmentTypeToJSON(message.Type);
    }
    if (message.Industry !== undefined) {
      obj.Industry = message.Industry;
    }
    if (message.Income !== undefined) {
      obj.Income = Income.toJSON(message.Income);
    }
    if (message.Contact !== undefined) {
      obj.Contact = EmployerContact.toJSON(message.Contact);
    }
    if (message.IsVerified !== false) {
      obj.IsVerified = message.IsVerified;
    }
    if (message.VerifiedAt !== "") {
      obj.VerifiedAt = message.VerifiedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Employment>, I>>(base?: I): Employment {
    return Employment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Employment>, I>>(object: I): Employment {
    const message = createBaseEmployment();
    message.EmployerName = object.EmployerName ?? "";
    message.JobTitle = object.JobTitle ?? "";
    message.StartDate = object.StartDate ?? undefined;
    message.EndDate = object.EndDate ?? undefined;
    message.Type = object.Type ?? 0;
    message.Industry = object.Industry ?? undefined;
    message.Income = (object.Income !== undefined && object.Income !== null)
      ? Income.fromPartial(object.Income)
      : undefined;
    message.Contact = (object.Contact !== undefined && object.Contact !== null)
      ? EmployerContact.fromPartial(object.Contact)
      : undefined;
    message.IsVerified = object.IsVerified ?? false;
    message.VerifiedAt = object.VerifiedAt ?? "";
    return message;
  },
};

function createBaseIncome(): Income {
  return { Amount: 0, Currency: "", Frequency: 0 };
}

export const Income = {
  encode(message: Income, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Amount !== 0) {
      writer.uint32(13).float(message.Amount);
    }
    if (message.Currency !== "") {
      writer.uint32(18).string(message.Currency);
    }
    if (message.Frequency !== 0) {
      writer.uint32(24).int32(message.Frequency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Income {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncome();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.Amount = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Currency = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Frequency = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Income {
    return {
      Amount: isSet(object.Amount) ? globalThis.Number(object.Amount) : 0,
      Currency: isSet(object.Currency) ? globalThis.String(object.Currency) : "",
      Frequency: isSet(object.Frequency) ? incomeFrequencyFromJSON(object.Frequency) : 0,
    };
  },

  toJSON(message: Income): unknown {
    const obj: any = {};
    if (message.Amount !== 0) {
      obj.Amount = message.Amount;
    }
    if (message.Currency !== "") {
      obj.Currency = message.Currency;
    }
    if (message.Frequency !== 0) {
      obj.Frequency = incomeFrequencyToJSON(message.Frequency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Income>, I>>(base?: I): Income {
    return Income.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Income>, I>>(object: I): Income {
    const message = createBaseIncome();
    message.Amount = object.Amount ?? 0;
    message.Currency = object.Currency ?? "";
    message.Frequency = object.Frequency ?? 0;
    return message;
  },
};

function createBaseEmployerContact(): EmployerContact {
  return { Name: "", Email: "", Phone: "", Address: "" };
}

export const EmployerContact = {
  encode(message: EmployerContact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Name !== "") {
      writer.uint32(10).string(message.Name);
    }
    if (message.Email !== "") {
      writer.uint32(18).string(message.Email);
    }
    if (message.Phone !== "") {
      writer.uint32(26).string(message.Phone);
    }
    if (message.Address !== "") {
      writer.uint32(34).string(message.Address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EmployerContact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmployerContact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Phone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmployerContact {
    return {
      Name: isSet(object.Name) ? globalThis.String(object.Name) : "",
      Email: isSet(object.Email) ? globalThis.String(object.Email) : "",
      Phone: isSet(object.Phone) ? globalThis.String(object.Phone) : "",
      Address: isSet(object.Address) ? globalThis.String(object.Address) : "",
    };
  },

  toJSON(message: EmployerContact): unknown {
    const obj: any = {};
    if (message.Name !== "") {
      obj.Name = message.Name;
    }
    if (message.Email !== "") {
      obj.Email = message.Email;
    }
    if (message.Phone !== "") {
      obj.Phone = message.Phone;
    }
    if (message.Address !== "") {
      obj.Address = message.Address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmployerContact>, I>>(base?: I): EmployerContact {
    return EmployerContact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmployerContact>, I>>(object: I): EmployerContact {
    const message = createBaseEmployerContact();
    message.Name = object.Name ?? "";
    message.Email = object.Email ?? "";
    message.Phone = object.Phone ?? "";
    message.Address = object.Address ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return { User: undefined, MetaData: undefined, Audit: undefined };
}

export const User = {
  encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.User !== undefined) {
      UserDetails.encode(message.User, writer.uint32(10).fork()).ldelim();
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(18).fork()).ldelim();
    }
    if (message.Audit !== undefined) {
      Audit.encode(message.Audit, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.User = UserDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Audit = Audit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      User: isSet(object.User) ? UserDetails.fromJSON(object.User) : undefined,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      Audit: isSet(object.Audit) ? Audit.fromJSON(object.Audit) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.User !== undefined) {
      obj.User = UserDetails.toJSON(message.User);
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.Audit !== undefined) {
      obj.Audit = Audit.toJSON(message.Audit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.User = (object.User !== undefined && object.User !== null)
      ? UserDetails.fromPartial(object.User)
      : undefined;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.Audit = (object.Audit !== undefined && object.Audit !== null) ? Audit.fromPartial(object.Audit) : undefined;
    return message;
  },
};

function createBaseUserID(): UserID {
  return { UserID: "", OrganizationID: "", Network: undefined };
}

export const UserID = {
  encode(message: UserID, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.UserID !== "") {
      writer.uint32(10).string(message.UserID);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(18).string(message.OrganizationID);
    }
    if (message.Network !== undefined) {
      writer.uint32(24).int32(message.Network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserID {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Network = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserID {
    return {
      UserID: isSet(object.UserID) ? globalThis.String(object.UserID) : "",
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Network: isSet(object.Network) ? networkFromJSON(object.Network) : undefined,
    };
  },

  toJSON(message: UserID): unknown {
    const obj: any = {};
    if (message.UserID !== "") {
      obj.UserID = message.UserID;
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Network !== undefined) {
      obj.Network = networkToJSON(message.Network);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserID>, I>>(base?: I): UserID {
    return UserID.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserID>, I>>(object: I): UserID {
    const message = createBaseUserID();
    message.UserID = object.UserID ?? "";
    message.OrganizationID = object.OrganizationID ?? "";
    message.Network = object.Network ?? undefined;
    return message;
  },
};

function createBaseSocial(): Social {
  return { URL: "", Type: 0 };
}

export const Social = {
  encode(message: Social, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.URL !== "") {
      writer.uint32(10).string(message.URL);
    }
    if (message.Type !== 0) {
      writer.uint32(16).int32(message.Type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Social {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSocial();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.URL = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Social {
    return {
      URL: isSet(object.URL) ? globalThis.String(object.URL) : "",
      Type: isSet(object.Type) ? socialTypeFromJSON(object.Type) : 0,
    };
  },

  toJSON(message: Social): unknown {
    const obj: any = {};
    if (message.URL !== "") {
      obj.URL = message.URL;
    }
    if (message.Type !== 0) {
      obj.Type = socialTypeToJSON(message.Type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Social>, I>>(base?: I): Social {
    return Social.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Social>, I>>(object: I): Social {
    const message = createBaseSocial();
    message.URL = object.URL ?? "";
    message.Type = object.Type ?? 0;
    return message;
  },
};

function createBaseWallet(): Wallet {
  return { Address: "", Alias: "", Type: 0, SignerType: 0 };
}

export const Wallet = {
  encode(message: Wallet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Address !== "") {
      writer.uint32(10).string(message.Address);
    }
    if (message.Alias !== "") {
      writer.uint32(18).string(message.Alias);
    }
    if (message.Type !== 0) {
      writer.uint32(24).int32(message.Type);
    }
    if (message.SignerType !== 0) {
      writer.uint32(32).int32(message.SignerType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Wallet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Alias = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.SignerType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wallet {
    return {
      Address: isSet(object.Address) ? globalThis.String(object.Address) : "",
      Alias: isSet(object.Alias) ? globalThis.String(object.Alias) : "",
      Type: isSet(object.Type) ? walletTypeFromJSON(object.Type) : 0,
      SignerType: isSet(object.SignerType) ? signerTypeFromJSON(object.SignerType) : 0,
    };
  },

  toJSON(message: Wallet): unknown {
    const obj: any = {};
    if (message.Address !== "") {
      obj.Address = message.Address;
    }
    if (message.Alias !== "") {
      obj.Alias = message.Alias;
    }
    if (message.Type !== 0) {
      obj.Type = walletTypeToJSON(message.Type);
    }
    if (message.SignerType !== 0) {
      obj.SignerType = signerTypeToJSON(message.SignerType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wallet>, I>>(base?: I): Wallet {
    return Wallet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wallet>, I>>(object: I): Wallet {
    const message = createBaseWallet();
    message.Address = object.Address ?? "";
    message.Alias = object.Alias ?? "";
    message.Type = object.Type ?? 0;
    message.SignerType = object.SignerType ?? 0;
    return message;
  },
};

function createBaseUserList(): UserList {
  return { Users: [], Offset: undefined };
}

export const UserList = {
  encode(message: UserList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Users) {
      User.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.Offset !== undefined) {
      writer.uint32(16).int32(message.Offset);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Users.push(User.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Offset = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserList {
    return {
      Users: globalThis.Array.isArray(object?.Users) ? object.Users.map((e: any) => User.fromJSON(e)) : [],
      Offset: isSet(object.Offset) ? globalThis.Number(object.Offset) : undefined,
    };
  },

  toJSON(message: UserList): unknown {
    const obj: any = {};
    if (message.Users?.length) {
      obj.Users = message.Users.map((e) => User.toJSON(e));
    }
    if (message.Offset !== undefined) {
      obj.Offset = Math.round(message.Offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserList>, I>>(base?: I): UserList {
    return UserList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserList>, I>>(object: I): UserList {
    const message = createBaseUserList();
    message.Users = object.Users?.map((e) => User.fromPartial(e)) || [];
    message.Offset = object.Offset ?? undefined;
    return message;
  },
};

function createBaseStatusMessage(): StatusMessage {
  return { UserID: "", OrganizationID: "", Status: 0, Network: undefined, Audit: undefined };
}

export const StatusMessage = {
  encode(message: StatusMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.UserID !== "") {
      writer.uint32(10).string(message.UserID);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(18).string(message.OrganizationID);
    }
    if (message.Status !== 0) {
      writer.uint32(24).int32(message.Status);
    }
    if (message.Network !== undefined) {
      writer.uint32(32).int32(message.Network);
    }
    if (message.Audit !== undefined) {
      Audit.encode(message.Audit, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.Network = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Audit = Audit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusMessage {
    return {
      UserID: isSet(object.UserID) ? globalThis.String(object.UserID) : "",
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Status: isSet(object.Status) ? userStatusFromJSON(object.Status) : 0,
      Network: isSet(object.Network) ? networkFromJSON(object.Network) : undefined,
      Audit: isSet(object.Audit) ? Audit.fromJSON(object.Audit) : undefined,
    };
  },

  toJSON(message: StatusMessage): unknown {
    const obj: any = {};
    if (message.UserID !== "") {
      obj.UserID = message.UserID;
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Status !== 0) {
      obj.Status = userStatusToJSON(message.Status);
    }
    if (message.Network !== undefined) {
      obj.Network = networkToJSON(message.Network);
    }
    if (message.Audit !== undefined) {
      obj.Audit = Audit.toJSON(message.Audit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusMessage>, I>>(base?: I): StatusMessage {
    return StatusMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusMessage>, I>>(object: I): StatusMessage {
    const message = createBaseStatusMessage();
    message.UserID = object.UserID ?? "";
    message.OrganizationID = object.OrganizationID ?? "";
    message.Status = object.Status ?? 0;
    message.Network = object.Network ?? undefined;
    message.Audit = (object.Audit !== undefined && object.Audit !== null) ? Audit.fromPartial(object.Audit) : undefined;
    return message;
  },
};

function createBaseFilter(): Filter {
  return {
    UserIDs: [],
    Network: undefined,
    OrganizationID: "",
    Offset: undefined,
    Limit: undefined,
    InquiryID: undefined,
    Status: undefined,
    ExternalUserIDs: [],
    WalletAddress: undefined,
  };
}

export const Filter = {
  encode(message: Filter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.UserIDs) {
      writer.uint32(10).string(v!);
    }
    if (message.Network !== undefined) {
      writer.uint32(16).int32(message.Network);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(26).string(message.OrganizationID);
    }
    if (message.Offset !== undefined) {
      writer.uint32(32).int32(message.Offset);
    }
    if (message.Limit !== undefined) {
      writer.uint32(40).int32(message.Limit);
    }
    if (message.InquiryID !== undefined) {
      writer.uint32(50).string(message.InquiryID);
    }
    if (message.Status !== undefined) {
      writer.uint32(56).int32(message.Status);
    }
    for (const v of message.ExternalUserIDs) {
      writer.uint32(66).string(v!);
    }
    if (message.WalletAddress !== undefined) {
      writer.uint32(74).string(message.WalletAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Filter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserIDs.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Network = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.Offset = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.Limit = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.InquiryID = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ExternalUserIDs.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.WalletAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      UserIDs: globalThis.Array.isArray(object?.UserIDs) ? object.UserIDs.map((e: any) => globalThis.String(e)) : [],
      Network: isSet(object.Network) ? networkFromJSON(object.Network) : undefined,
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Offset: isSet(object.Offset) ? globalThis.Number(object.Offset) : undefined,
      Limit: isSet(object.Limit) ? globalThis.Number(object.Limit) : undefined,
      InquiryID: isSet(object.InquiryID) ? globalThis.String(object.InquiryID) : undefined,
      Status: isSet(object.Status) ? userStatusFromJSON(object.Status) : undefined,
      ExternalUserIDs: globalThis.Array.isArray(object?.ExternalUserIDs)
        ? object.ExternalUserIDs.map((e: any) => globalThis.String(e))
        : [],
      WalletAddress: isSet(object.WalletAddress) ? globalThis.String(object.WalletAddress) : undefined,
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.UserIDs?.length) {
      obj.UserIDs = message.UserIDs;
    }
    if (message.Network !== undefined) {
      obj.Network = networkToJSON(message.Network);
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Offset !== undefined) {
      obj.Offset = Math.round(message.Offset);
    }
    if (message.Limit !== undefined) {
      obj.Limit = Math.round(message.Limit);
    }
    if (message.InquiryID !== undefined) {
      obj.InquiryID = message.InquiryID;
    }
    if (message.Status !== undefined) {
      obj.Status = userStatusToJSON(message.Status);
    }
    if (message.ExternalUserIDs?.length) {
      obj.ExternalUserIDs = message.ExternalUserIDs;
    }
    if (message.WalletAddress !== undefined) {
      obj.WalletAddress = message.WalletAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Filter>, I>>(base?: I): Filter {
    return Filter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Filter>, I>>(object: I): Filter {
    const message = createBaseFilter();
    message.UserIDs = object.UserIDs?.map((e) => e) || [];
    message.Network = object.Network ?? undefined;
    message.OrganizationID = object.OrganizationID ?? "";
    message.Offset = object.Offset ?? undefined;
    message.Limit = object.Limit ?? undefined;
    message.InquiryID = object.InquiryID ?? undefined;
    message.Status = object.Status ?? undefined;
    message.ExternalUserIDs = object.ExternalUserIDs?.map((e) => e) || [];
    message.WalletAddress = object.WalletAddress ?? undefined;
    return message;
  },
};

function createBaseComplianceQuestions(): ComplianceQuestions {
  return { USA: undefined };
}

export const ComplianceQuestions = {
  encode(message: ComplianceQuestions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.USA !== undefined) {
      USA.encode(message.USA, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComplianceQuestions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceQuestions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.USA = USA.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceQuestions {
    return { USA: isSet(object.USA) ? USA.fromJSON(object.USA) : undefined };
  },

  toJSON(message: ComplianceQuestions): unknown {
    const obj: any = {};
    if (message.USA !== undefined) {
      obj.USA = USA.toJSON(message.USA);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComplianceQuestions>, I>>(base?: I): ComplianceQuestions {
    return ComplianceQuestions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComplianceQuestions>, I>>(object: I): ComplianceQuestions {
    const message = createBaseComplianceQuestions();
    message.USA = (object.USA !== undefined && object.USA !== null) ? USA.fromPartial(object.USA) : undefined;
    return message;
  },
};

function createBaseUSA(): USA {
  return {
    RecordedAt: undefined,
    YearsExperience: 0,
    AnnualIncome: 0,
    NetWorth: 0,
    ConversionImportance: 0,
    Tolerance: 0,
    Objective: 0,
  };
}

export const USA = {
  encode(message: USA, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.RecordedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.RecordedAt), writer.uint32(10).fork()).ldelim();
    }
    if (message.YearsExperience !== 0) {
      writer.uint32(16).int64(message.YearsExperience);
    }
    if (message.AnnualIncome !== 0) {
      writer.uint32(24).int64(message.AnnualIncome);
    }
    if (message.NetWorth !== 0) {
      writer.uint32(32).int64(message.NetWorth);
    }
    if (message.ConversionImportance !== 0) {
      writer.uint32(40).int32(message.ConversionImportance);
    }
    if (message.Tolerance !== 0) {
      writer.uint32(48).int32(message.Tolerance);
    }
    if (message.Objective !== 0) {
      writer.uint32(56).int32(message.Objective);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): USA {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUSA();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.RecordedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.YearsExperience = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.AnnualIncome = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.NetWorth = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ConversionImportance = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.Tolerance = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.Objective = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): USA {
    return {
      RecordedAt: isSet(object.RecordedAt) ? fromJsonTimestamp(object.RecordedAt) : undefined,
      YearsExperience: isSet(object.YearsExperience) ? globalThis.Number(object.YearsExperience) : 0,
      AnnualIncome: isSet(object.AnnualIncome) ? globalThis.Number(object.AnnualIncome) : 0,
      NetWorth: isSet(object.NetWorth) ? globalThis.Number(object.NetWorth) : 0,
      ConversionImportance: isSet(object.ConversionImportance)
        ? liquidationImportanceFromJSON(object.ConversionImportance)
        : 0,
      Tolerance: isSet(object.Tolerance) ? riskToleranceFromJSON(object.Tolerance) : 0,
      Objective: isSet(object.Objective) ? investmentObjectiveFromJSON(object.Objective) : 0,
    };
  },

  toJSON(message: USA): unknown {
    const obj: any = {};
    if (message.RecordedAt !== undefined) {
      obj.RecordedAt = message.RecordedAt.toISOString();
    }
    if (message.YearsExperience !== 0) {
      obj.YearsExperience = Math.round(message.YearsExperience);
    }
    if (message.AnnualIncome !== 0) {
      obj.AnnualIncome = Math.round(message.AnnualIncome);
    }
    if (message.NetWorth !== 0) {
      obj.NetWorth = Math.round(message.NetWorth);
    }
    if (message.ConversionImportance !== 0) {
      obj.ConversionImportance = liquidationImportanceToJSON(message.ConversionImportance);
    }
    if (message.Tolerance !== 0) {
      obj.Tolerance = riskToleranceToJSON(message.Tolerance);
    }
    if (message.Objective !== 0) {
      obj.Objective = investmentObjectiveToJSON(message.Objective);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<USA>, I>>(base?: I): USA {
    return USA.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<USA>, I>>(object: I): USA {
    const message = createBaseUSA();
    message.RecordedAt = object.RecordedAt ?? undefined;
    message.YearsExperience = object.YearsExperience ?? 0;
    message.AnnualIncome = object.AnnualIncome ?? 0;
    message.NetWorth = object.NetWorth ?? 0;
    message.ConversionImportance = object.ConversionImportance ?? 0;
    message.Tolerance = object.Tolerance ?? 0;
    message.Objective = object.Objective ?? 0;
    return message;
  },
};

function createBaseBankAccount(): BankAccount {
  return { AccountName: "", BankName: "", BankAddress: "", AccountNumber: "", ABA: "", SWIFT: "", IBAN: "" };
}

export const BankAccount = {
  encode(message: BankAccount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.AccountName !== "") {
      writer.uint32(10).string(message.AccountName);
    }
    if (message.BankName !== "") {
      writer.uint32(18).string(message.BankName);
    }
    if (message.BankAddress !== "") {
      writer.uint32(26).string(message.BankAddress);
    }
    if (message.AccountNumber !== "") {
      writer.uint32(34).string(message.AccountNumber);
    }
    if (message.ABA !== "") {
      writer.uint32(42).string(message.ABA);
    }
    if (message.SWIFT !== "") {
      writer.uint32(50).string(message.SWIFT);
    }
    if (message.IBAN !== "") {
      writer.uint32(58).string(message.IBAN);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BankAccount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBankAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.AccountName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.BankName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.BankAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.AccountNumber = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ABA = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.SWIFT = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.IBAN = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BankAccount {
    return {
      AccountName: isSet(object.AccountName) ? globalThis.String(object.AccountName) : "",
      BankName: isSet(object.BankName) ? globalThis.String(object.BankName) : "",
      BankAddress: isSet(object.BankAddress) ? globalThis.String(object.BankAddress) : "",
      AccountNumber: isSet(object.AccountNumber) ? globalThis.String(object.AccountNumber) : "",
      ABA: isSet(object.ABA) ? globalThis.String(object.ABA) : "",
      SWIFT: isSet(object.SWIFT) ? globalThis.String(object.SWIFT) : "",
      IBAN: isSet(object.IBAN) ? globalThis.String(object.IBAN) : "",
    };
  },

  toJSON(message: BankAccount): unknown {
    const obj: any = {};
    if (message.AccountName !== "") {
      obj.AccountName = message.AccountName;
    }
    if (message.BankName !== "") {
      obj.BankName = message.BankName;
    }
    if (message.BankAddress !== "") {
      obj.BankAddress = message.BankAddress;
    }
    if (message.AccountNumber !== "") {
      obj.AccountNumber = message.AccountNumber;
    }
    if (message.ABA !== "") {
      obj.ABA = message.ABA;
    }
    if (message.SWIFT !== "") {
      obj.SWIFT = message.SWIFT;
    }
    if (message.IBAN !== "") {
      obj.IBAN = message.IBAN;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BankAccount>, I>>(base?: I): BankAccount {
    return BankAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BankAccount>, I>>(object: I): BankAccount {
    const message = createBaseBankAccount();
    message.AccountName = object.AccountName ?? "";
    message.BankName = object.BankName ?? "";
    message.BankAddress = object.BankAddress ?? "";
    message.AccountNumber = object.AccountNumber ?? "";
    message.ABA = object.ABA ?? "";
    message.SWIFT = object.SWIFT ?? "";
    message.IBAN = object.IBAN ?? "";
    return message;
  },
};

function createBaseBrokerAccount(): BrokerAccount {
  return { AccountID: "", Broker: 0, OrganizationID: "", Profiles: [] };
}

export const BrokerAccount = {
  encode(message: BrokerAccount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.AccountID !== "") {
      writer.uint32(10).string(message.AccountID);
    }
    if (message.Broker !== 0) {
      writer.uint32(16).int32(message.Broker);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(26).string(message.OrganizationID);
    }
    for (const v of message.Profiles) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BrokerAccount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.AccountID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Broker = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Profiles.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrokerAccount {
    return {
      AccountID: isSet(object.AccountID) ? globalThis.String(object.AccountID) : "",
      Broker: isSet(object.Broker) ? clearingBrokerFromJSON(object.Broker) : 0,
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Profiles: globalThis.Array.isArray(object?.Profiles) ? object.Profiles.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BrokerAccount): unknown {
    const obj: any = {};
    if (message.AccountID !== "") {
      obj.AccountID = message.AccountID;
    }
    if (message.Broker !== 0) {
      obj.Broker = clearingBrokerToJSON(message.Broker);
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Profiles?.length) {
      obj.Profiles = message.Profiles;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BrokerAccount>, I>>(base?: I): BrokerAccount {
    return BrokerAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BrokerAccount>, I>>(object: I): BrokerAccount {
    const message = createBaseBrokerAccount();
    message.AccountID = object.AccountID ?? "";
    message.Broker = object.Broker ?? 0;
    message.OrganizationID = object.OrganizationID ?? "";
    message.Profiles = object.Profiles?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
