// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.32.0
// source: sologenic/com-fs-asset-model/asset.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Audit } from "../com-fs-utils-lib/models/audit/audit";
import { MetaData } from "../com-fs-utils-lib/models/metadata/metadata";
import { Denom } from "./domain/denom/denom";

export const protobufPackage = "asset";

export enum AssetStatus {
  ASSET_STATUS_DO_NOT_USE = 0,
  /** DO_NOT_LIST - BROKER_ASSET_ADMINISTRATOR only */
  DO_NOT_LIST = 1,
  /** REQUEST_LISTING - BROKER_ASSET_ADMINISTRATOR only */
  REQUEST_LISTING = 2,
  /** LISTED - ORGANIZATION_ASSET_ADMINISTRATOR only */
  LISTED = 3,
  /** ORGANIZATION_ADMIN_DO_NOT_LIST - ORGANIZATION_ASSET_ADMINISTRATOR only */
  ORGANIZATION_ADMIN_DO_NOT_LIST = 4,
  OUTDATED_ASSET_VERSION = 5,
  UNRECOGNIZED = -1,
}

export function assetStatusFromJSON(object: any): AssetStatus {
  switch (object) {
    case 0:
    case "ASSET_STATUS_DO_NOT_USE":
      return AssetStatus.ASSET_STATUS_DO_NOT_USE;
    case 1:
    case "DO_NOT_LIST":
      return AssetStatus.DO_NOT_LIST;
    case 2:
    case "REQUEST_LISTING":
      return AssetStatus.REQUEST_LISTING;
    case 3:
    case "LISTED":
      return AssetStatus.LISTED;
    case 4:
    case "ORGANIZATION_ADMIN_DO_NOT_LIST":
      return AssetStatus.ORGANIZATION_ADMIN_DO_NOT_LIST;
    case 5:
    case "OUTDATED_ASSET_VERSION":
      return AssetStatus.OUTDATED_ASSET_VERSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AssetStatus.UNRECOGNIZED;
  }
}

export function assetStatusToJSON(object: AssetStatus): string {
  switch (object) {
    case AssetStatus.ASSET_STATUS_DO_NOT_USE:
      return "ASSET_STATUS_DO_NOT_USE";
    case AssetStatus.DO_NOT_LIST:
      return "DO_NOT_LIST";
    case AssetStatus.REQUEST_LISTING:
      return "REQUEST_LISTING";
    case AssetStatus.LISTED:
      return "LISTED";
    case AssetStatus.ORGANIZATION_ADMIN_DO_NOT_LIST:
      return "ORGANIZATION_ADMIN_DO_NOT_LIST";
    case AssetStatus.OUTDATED_ASSET_VERSION:
      return "OUTDATED_ASSET_VERSION";
    case AssetStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Reason {
  REASON_DO_NOT_USE = 0,
  DUPLICATE = 1,
  UNWANTED_ASSET = 2,
  UNSTABLE_ASSET = 3,
  UNRECOGNIZED = -1,
}

export function reasonFromJSON(object: any): Reason {
  switch (object) {
    case 0:
    case "REASON_DO_NOT_USE":
      return Reason.REASON_DO_NOT_USE;
    case 1:
    case "DUPLICATE":
      return Reason.DUPLICATE;
    case 2:
    case "UNWANTED_ASSET":
      return Reason.UNWANTED_ASSET;
    case 3:
    case "UNSTABLE_ASSET":
      return Reason.UNSTABLE_ASSET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Reason.UNRECOGNIZED;
  }
}

export function reasonToJSON(object: Reason): string {
  switch (object) {
    case Reason.REASON_DO_NOT_USE:
      return "REASON_DO_NOT_USE";
    case Reason.DUPLICATE:
      return "DUPLICATE";
    case Reason.UNWANTED_ASSET:
      return "UNWANTED_ASSET";
    case Reason.UNSTABLE_ASSET:
      return "UNSTABLE_ASSET";
    case Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TODO: to have shared between order */
export enum AssetType {
  ASSET_TYPE_DO_NOT_USE = 0,
  STOCKS = 1,
  BONDS = 2,
  /** WRAPPED_STABLECOIN - Represents a stablecoin that is wrapped for internal use within the system, such as WUSDC. */
  WRAPPED_STABLECOIN = 3,
  CRYPTO = 4,
  FOREX = 5,
  FUTURES = 6,
  OPTIONS = 7,
  UNRECOGNIZED = -1,
}

export function assetTypeFromJSON(object: any): AssetType {
  switch (object) {
    case 0:
    case "ASSET_TYPE_DO_NOT_USE":
      return AssetType.ASSET_TYPE_DO_NOT_USE;
    case 1:
    case "STOCKS":
      return AssetType.STOCKS;
    case 2:
    case "BONDS":
      return AssetType.BONDS;
    case 3:
    case "WRAPPED_STABLECOIN":
      return AssetType.WRAPPED_STABLECOIN;
    case 4:
    case "CRYPTO":
      return AssetType.CRYPTO;
    case 5:
    case "FOREX":
      return AssetType.FOREX;
    case 6:
    case "FUTURES":
      return AssetType.FUTURES;
    case 7:
    case "OPTIONS":
      return AssetType.OPTIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AssetType.UNRECOGNIZED;
  }
}

export function assetTypeToJSON(object: AssetType): string {
  switch (object) {
    case AssetType.ASSET_TYPE_DO_NOT_USE:
      return "ASSET_TYPE_DO_NOT_USE";
    case AssetType.STOCKS:
      return "STOCKS";
    case AssetType.BONDS:
      return "BONDS";
    case AssetType.WRAPPED_STABLECOIN:
      return "WRAPPED_STABLECOIN";
    case AssetType.CRYPTO:
      return "CRYPTO";
    case AssetType.FOREX:
      return "FOREX";
    case AssetType.FUTURES:
      return "FUTURES";
    case AssetType.OPTIONS:
      return "OPTIONS";
    case AssetType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UserAssetStatus {
  USER_ASSET_STATUS_DO_NOT_USE = 0,
  NOT_WHITELISTED = 1,
  WHITELISTING_REQUESTED = 2,
  WHITELISTED = 3,
  OUTDATED_VERSION = 4,
  UNRECOGNIZED = -1,
}

export function userAssetStatusFromJSON(object: any): UserAssetStatus {
  switch (object) {
    case 0:
    case "USER_ASSET_STATUS_DO_NOT_USE":
      return UserAssetStatus.USER_ASSET_STATUS_DO_NOT_USE;
    case 1:
    case "NOT_WHITELISTED":
      return UserAssetStatus.NOT_WHITELISTED;
    case 2:
    case "WHITELISTING_REQUESTED":
      return UserAssetStatus.WHITELISTING_REQUESTED;
    case 3:
    case "WHITELISTED":
      return UserAssetStatus.WHITELISTED;
    case 4:
    case "OUTDATED_VERSION":
      return UserAssetStatus.OUTDATED_VERSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserAssetStatus.UNRECOGNIZED;
  }
}

export function userAssetStatusToJSON(object: UserAssetStatus): string {
  switch (object) {
    case UserAssetStatus.USER_ASSET_STATUS_DO_NOT_USE:
      return "USER_ASSET_STATUS_DO_NOT_USE";
    case UserAssetStatus.NOT_WHITELISTED:
      return "NOT_WHITELISTED";
    case UserAssetStatus.WHITELISTING_REQUESTED:
      return "WHITELISTING_REQUESTED";
    case UserAssetStatus.WHITELISTED:
      return "WHITELISTED";
    case UserAssetStatus.OUTDATED_VERSION:
      return "OUTDATED_VERSION";
    case UserAssetStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Exchange {
  EXCHANGE_DO_NOT_USE = 0,
  NASDAQ = 1,
  NYSE = 2,
  /** ONCHAIN - On‑chain token/cryptocurrency markets, e.g. wrapped USDC */
  ONCHAIN = 3,
  UNRECOGNIZED = -1,
}

export function exchangeFromJSON(object: any): Exchange {
  switch (object) {
    case 0:
    case "EXCHANGE_DO_NOT_USE":
      return Exchange.EXCHANGE_DO_NOT_USE;
    case 1:
    case "NASDAQ":
      return Exchange.NASDAQ;
    case 2:
    case "NYSE":
      return Exchange.NYSE;
    case 3:
    case "ONCHAIN":
      return Exchange.ONCHAIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Exchange.UNRECOGNIZED;
  }
}

export function exchangeToJSON(object: Exchange): string {
  switch (object) {
    case Exchange.EXCHANGE_DO_NOT_USE:
      return "EXCHANGE_DO_NOT_USE";
    case Exchange.NASDAQ:
      return "NASDAQ";
    case Exchange.NYSE:
      return "NYSE";
    case Exchange.ONCHAIN:
      return "ONCHAIN";
    case Exchange.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Global Industry Classification Standard (GICS®) 11 sectors
 * Source: https://www.msci.com/our-solutions/indexes/gics
 */
export enum Industry {
  INDUSTRY_DO_NOT_USE = 0,
  ENERGY = 1,
  MATERIALS = 2,
  INDUSTRIALS = 3,
  CONSUMER_DISCRETIONARY = 4,
  CONSUMER_STAPLES = 5,
  HEALTH_CARE = 6,
  FINANCIALS = 7,
  INFORMATION_TECHNOLOGY = 8,
  COMMUNICATION_SERVICES = 9,
  UTILITIES = 10,
  REAL_ESTATE = 11,
  UNRECOGNIZED = -1,
}

export function industryFromJSON(object: any): Industry {
  switch (object) {
    case 0:
    case "INDUSTRY_DO_NOT_USE":
      return Industry.INDUSTRY_DO_NOT_USE;
    case 1:
    case "ENERGY":
      return Industry.ENERGY;
    case 2:
    case "MATERIALS":
      return Industry.MATERIALS;
    case 3:
    case "INDUSTRIALS":
      return Industry.INDUSTRIALS;
    case 4:
    case "CONSUMER_DISCRETIONARY":
      return Industry.CONSUMER_DISCRETIONARY;
    case 5:
    case "CONSUMER_STAPLES":
      return Industry.CONSUMER_STAPLES;
    case 6:
    case "HEALTH_CARE":
      return Industry.HEALTH_CARE;
    case 7:
    case "FINANCIALS":
      return Industry.FINANCIALS;
    case 8:
    case "INFORMATION_TECHNOLOGY":
      return Industry.INFORMATION_TECHNOLOGY;
    case 9:
    case "COMMUNICATION_SERVICES":
      return Industry.COMMUNICATION_SERVICES;
    case 10:
    case "UTILITIES":
      return Industry.UTILITIES;
    case 11:
    case "REAL_ESTATE":
      return Industry.REAL_ESTATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Industry.UNRECOGNIZED;
  }
}

export function industryToJSON(object: Industry): string {
  switch (object) {
    case Industry.INDUSTRY_DO_NOT_USE:
      return "INDUSTRY_DO_NOT_USE";
    case Industry.ENERGY:
      return "ENERGY";
    case Industry.MATERIALS:
      return "MATERIALS";
    case Industry.INDUSTRIALS:
      return "INDUSTRIALS";
    case Industry.CONSUMER_DISCRETIONARY:
      return "CONSUMER_DISCRETIONARY";
    case Industry.CONSUMER_STAPLES:
      return "CONSUMER_STAPLES";
    case Industry.HEALTH_CARE:
      return "HEALTH_CARE";
    case Industry.FINANCIALS:
      return "FINANCIALS";
    case Industry.INFORMATION_TECHNOLOGY:
      return "INFORMATION_TECHNOLOGY";
    case Industry.COMMUNICATION_SERVICES:
      return "COMMUNICATION_SERVICES";
    case Industry.UTILITIES:
      return "UTILITIES";
    case Industry.REAL_ESTATE:
      return "REAL_ESTATE";
    case Industry.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AssetDetails {
  /** Key combination: Currency_OrganizationID_SmartContractIssuerAddr e.g "appl_1_72c4c072-2fe4-4f72-ae9d-d9d52a05fd71_testcore1et29c..." */
  ID: string;
  /** External entity (broker) that owns this asset */
  OrganizationID: string;
  Status: AssetStatus;
  Reason?:
    | Reason
    | undefined;
  /** list of jurisdictionIDs where this asset is allowed to be traded */
  JurisdictionIDs: string[];
  Type: AssetType;
  /** Asset specific properties */
  Name: string;
  ExchangeTickerSymbol: string;
  Exchange: Exchange;
  /** Description for internal use, not for on-chain */
  InternalDescription: string;
  MinTransactionAmount: number;
  /**
   * TradingMarginPercentage is required additional margin as a percentage of the order value that buyers must provide.
   * Value should be between 0.0 and 1.0 (0% to 100%)
   * Example: If TradingMarginPercentage = 0.1 (10%) and order value is $100:
   *  - Buyer must provide $110 total ($100 asset cost + $10 margin)
   *  - $5 (5%, cost) is kept for transaction costs
   *  - $5 (5%, refundable) is returned to the buyer after execution
   */
  TradingMarginPercentage: number;
  LogoFile:
    | LogoFile
    | undefined;
  /** Global Industry Classification Standard (GICS®) sector */
  Industry: Industry;
  /**
   * Margin percentage specific to the asset. This is the asset's individual margin percentage used to calculate buying power.
   * Buying Power = AvailableFunds(On-chain) + (Σ Assets(non-stablecoin)  × AssetMarginPercentage)
   * Asset Margin Percentage: represents the collateral value of the asset (e.g., 50% → 10,000BTC → 10,000BTC → 5,000 buying power contribution)
   */
  AssetMarginPercentage: number;
  /** On-chain properties */
  Denom:
    | Denom
    | undefined;
  /** Flag to indicate if the asset is issued in the smart contract */
  IsIssuedInSmartContract: boolean;
  /** Issuer address of the smart contract (distinct from Denom.Issuer which is the smart contract address that minted the token) */
  SmartContractIssuerAddr: string;
}

export interface Asset {
  AssetDetails: AssetDetails | undefined;
  MetaData: MetaData | undefined;
  Audit: Audit | undefined;
}

export interface Assets {
  Assets: Asset[];
}

export interface LogoFile {
  /** The reference to the file */
  Reference: string;
  Extension: string;
  /** User defined name of the file, used as a "description" and not to reference the file */
  Name?: string | undefined;
}

export interface UserAssetList {
  /** Key combination: Currency-OrganizationID-AccountID-Wallet (AssetKey-AccountID-Wallet) */
  AccountID: string;
  Wallet: string;
  /** Currency-OrganizationID */
  AssetKey: string;
  Status: UserAssetStatus;
  MetaData: MetaData | undefined;
  Visible: boolean;
}

export interface UserAssetLists {
  UserAssetLists: UserAssetList[];
}

function createBaseAssetDetails(): AssetDetails {
  return {
    ID: "",
    OrganizationID: "",
    Status: 0,
    Reason: undefined,
    JurisdictionIDs: [],
    Type: 0,
    Name: "",
    ExchangeTickerSymbol: "",
    Exchange: 0,
    InternalDescription: "",
    MinTransactionAmount: 0,
    TradingMarginPercentage: 0,
    LogoFile: undefined,
    Industry: 0,
    AssetMarginPercentage: 0,
    Denom: undefined,
    IsIssuedInSmartContract: false,
    SmartContractIssuerAddr: "",
  };
}

export const AssetDetails = {
  encode(message: AssetDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ID !== "") {
      writer.uint32(10).string(message.ID);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(18).string(message.OrganizationID);
    }
    if (message.Status !== 0) {
      writer.uint32(24).int32(message.Status);
    }
    if (message.Reason !== undefined) {
      writer.uint32(32).int32(message.Reason);
    }
    for (const v of message.JurisdictionIDs) {
      writer.uint32(42).string(v!);
    }
    if (message.Type !== 0) {
      writer.uint32(48).int32(message.Type);
    }
    if (message.Name !== "") {
      writer.uint32(58).string(message.Name);
    }
    if (message.ExchangeTickerSymbol !== "") {
      writer.uint32(66).string(message.ExchangeTickerSymbol);
    }
    if (message.Exchange !== 0) {
      writer.uint32(72).int32(message.Exchange);
    }
    if (message.InternalDescription !== "") {
      writer.uint32(82).string(message.InternalDescription);
    }
    if (message.MinTransactionAmount !== 0) {
      writer.uint32(89).double(message.MinTransactionAmount);
    }
    if (message.TradingMarginPercentage !== 0) {
      writer.uint32(97).double(message.TradingMarginPercentage);
    }
    if (message.LogoFile !== undefined) {
      LogoFile.encode(message.LogoFile, writer.uint32(106).fork()).ldelim();
    }
    if (message.Industry !== 0) {
      writer.uint32(112).int32(message.Industry);
    }
    if (message.AssetMarginPercentage !== 0) {
      writer.uint32(121).double(message.AssetMarginPercentage);
    }
    if (message.Denom !== undefined) {
      Denom.encode(message.Denom, writer.uint32(138).fork()).ldelim();
    }
    if (message.IsIssuedInSmartContract !== false) {
      writer.uint32(144).bool(message.IsIssuedInSmartContract);
    }
    if (message.SmartContractIssuerAddr !== "") {
      writer.uint32(154).string(message.SmartContractIssuerAddr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.Reason = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.JurisdictionIDs.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.Name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ExchangeTickerSymbol = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.Exchange = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.InternalDescription = reader.string();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.MinTransactionAmount = reader.double();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.TradingMarginPercentage = reader.double();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.LogoFile = LogoFile.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.Industry = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 121) {
            break;
          }

          message.AssetMarginPercentage = reader.double();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.Denom = Denom.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.IsIssuedInSmartContract = reader.bool();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.SmartContractIssuerAddr = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetDetails {
    return {
      ID: isSet(object.ID) ? globalThis.String(object.ID) : "",
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Status: isSet(object.Status) ? assetStatusFromJSON(object.Status) : 0,
      Reason: isSet(object.Reason) ? reasonFromJSON(object.Reason) : undefined,
      JurisdictionIDs: globalThis.Array.isArray(object?.JurisdictionIDs)
        ? object.JurisdictionIDs.map((e: any) => globalThis.String(e))
        : [],
      Type: isSet(object.Type) ? assetTypeFromJSON(object.Type) : 0,
      Name: isSet(object.Name) ? globalThis.String(object.Name) : "",
      ExchangeTickerSymbol: isSet(object.ExchangeTickerSymbol) ? globalThis.String(object.ExchangeTickerSymbol) : "",
      Exchange: isSet(object.Exchange) ? exchangeFromJSON(object.Exchange) : 0,
      InternalDescription: isSet(object.InternalDescription) ? globalThis.String(object.InternalDescription) : "",
      MinTransactionAmount: isSet(object.MinTransactionAmount) ? globalThis.Number(object.MinTransactionAmount) : 0,
      TradingMarginPercentage: isSet(object.TradingMarginPercentage)
        ? globalThis.Number(object.TradingMarginPercentage)
        : 0,
      LogoFile: isSet(object.LogoFile) ? LogoFile.fromJSON(object.LogoFile) : undefined,
      Industry: isSet(object.Industry) ? industryFromJSON(object.Industry) : 0,
      AssetMarginPercentage: isSet(object.AssetMarginPercentage) ? globalThis.Number(object.AssetMarginPercentage) : 0,
      Denom: isSet(object.Denom) ? Denom.fromJSON(object.Denom) : undefined,
      IsIssuedInSmartContract: isSet(object.IsIssuedInSmartContract)
        ? globalThis.Boolean(object.IsIssuedInSmartContract)
        : false,
      SmartContractIssuerAddr: isSet(object.SmartContractIssuerAddr)
        ? globalThis.String(object.SmartContractIssuerAddr)
        : "",
    };
  },

  toJSON(message: AssetDetails): unknown {
    const obj: any = {};
    if (message.ID !== "") {
      obj.ID = message.ID;
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Status !== 0) {
      obj.Status = assetStatusToJSON(message.Status);
    }
    if (message.Reason !== undefined) {
      obj.Reason = reasonToJSON(message.Reason);
    }
    if (message.JurisdictionIDs?.length) {
      obj.JurisdictionIDs = message.JurisdictionIDs;
    }
    if (message.Type !== 0) {
      obj.Type = assetTypeToJSON(message.Type);
    }
    if (message.Name !== "") {
      obj.Name = message.Name;
    }
    if (message.ExchangeTickerSymbol !== "") {
      obj.ExchangeTickerSymbol = message.ExchangeTickerSymbol;
    }
    if (message.Exchange !== 0) {
      obj.Exchange = exchangeToJSON(message.Exchange);
    }
    if (message.InternalDescription !== "") {
      obj.InternalDescription = message.InternalDescription;
    }
    if (message.MinTransactionAmount !== 0) {
      obj.MinTransactionAmount = message.MinTransactionAmount;
    }
    if (message.TradingMarginPercentage !== 0) {
      obj.TradingMarginPercentage = message.TradingMarginPercentage;
    }
    if (message.LogoFile !== undefined) {
      obj.LogoFile = LogoFile.toJSON(message.LogoFile);
    }
    if (message.Industry !== 0) {
      obj.Industry = industryToJSON(message.Industry);
    }
    if (message.AssetMarginPercentage !== 0) {
      obj.AssetMarginPercentage = message.AssetMarginPercentage;
    }
    if (message.Denom !== undefined) {
      obj.Denom = Denom.toJSON(message.Denom);
    }
    if (message.IsIssuedInSmartContract !== false) {
      obj.IsIssuedInSmartContract = message.IsIssuedInSmartContract;
    }
    if (message.SmartContractIssuerAddr !== "") {
      obj.SmartContractIssuerAddr = message.SmartContractIssuerAddr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetDetails>, I>>(base?: I): AssetDetails {
    return AssetDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetDetails>, I>>(object: I): AssetDetails {
    const message = createBaseAssetDetails();
    message.ID = object.ID ?? "";
    message.OrganizationID = object.OrganizationID ?? "";
    message.Status = object.Status ?? 0;
    message.Reason = object.Reason ?? undefined;
    message.JurisdictionIDs = object.JurisdictionIDs?.map((e) => e) || [];
    message.Type = object.Type ?? 0;
    message.Name = object.Name ?? "";
    message.ExchangeTickerSymbol = object.ExchangeTickerSymbol ?? "";
    message.Exchange = object.Exchange ?? 0;
    message.InternalDescription = object.InternalDescription ?? "";
    message.MinTransactionAmount = object.MinTransactionAmount ?? 0;
    message.TradingMarginPercentage = object.TradingMarginPercentage ?? 0;
    message.LogoFile = (object.LogoFile !== undefined && object.LogoFile !== null)
      ? LogoFile.fromPartial(object.LogoFile)
      : undefined;
    message.Industry = object.Industry ?? 0;
    message.AssetMarginPercentage = object.AssetMarginPercentage ?? 0;
    message.Denom = (object.Denom !== undefined && object.Denom !== null) ? Denom.fromPartial(object.Denom) : undefined;
    message.IsIssuedInSmartContract = object.IsIssuedInSmartContract ?? false;
    message.SmartContractIssuerAddr = object.SmartContractIssuerAddr ?? "";
    return message;
  },
};

function createBaseAsset(): Asset {
  return { AssetDetails: undefined, MetaData: undefined, Audit: undefined };
}

export const Asset = {
  encode(message: Asset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.AssetDetails !== undefined) {
      AssetDetails.encode(message.AssetDetails, writer.uint32(10).fork()).ldelim();
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(18).fork()).ldelim();
    }
    if (message.Audit !== undefined) {
      Audit.encode(message.Audit, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Asset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.AssetDetails = AssetDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Audit = Audit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      AssetDetails: isSet(object.AssetDetails) ? AssetDetails.fromJSON(object.AssetDetails) : undefined,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      Audit: isSet(object.Audit) ? Audit.fromJSON(object.Audit) : undefined,
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.AssetDetails !== undefined) {
      obj.AssetDetails = AssetDetails.toJSON(message.AssetDetails);
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.Audit !== undefined) {
      obj.Audit = Audit.toJSON(message.Audit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Asset>, I>>(base?: I): Asset {
    return Asset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Asset>, I>>(object: I): Asset {
    const message = createBaseAsset();
    message.AssetDetails = (object.AssetDetails !== undefined && object.AssetDetails !== null)
      ? AssetDetails.fromPartial(object.AssetDetails)
      : undefined;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.Audit = (object.Audit !== undefined && object.Audit !== null) ? Audit.fromPartial(object.Audit) : undefined;
    return message;
  },
};

function createBaseAssets(): Assets {
  return { Assets: [] };
}

export const Assets = {
  encode(message: Assets, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Assets) {
      Asset.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Assets {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Assets.push(Asset.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Assets {
    return { Assets: globalThis.Array.isArray(object?.Assets) ? object.Assets.map((e: any) => Asset.fromJSON(e)) : [] };
  },

  toJSON(message: Assets): unknown {
    const obj: any = {};
    if (message.Assets?.length) {
      obj.Assets = message.Assets.map((e) => Asset.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Assets>, I>>(base?: I): Assets {
    return Assets.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Assets>, I>>(object: I): Assets {
    const message = createBaseAssets();
    message.Assets = object.Assets?.map((e) => Asset.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLogoFile(): LogoFile {
  return { Reference: "", Extension: "", Name: undefined };
}

export const LogoFile = {
  encode(message: LogoFile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Reference !== "") {
      writer.uint32(10).string(message.Reference);
    }
    if (message.Extension !== "") {
      writer.uint32(18).string(message.Extension);
    }
    if (message.Name !== undefined) {
      writer.uint32(26).string(message.Name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogoFile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Reference = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Extension = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoFile {
    return {
      Reference: isSet(object.Reference) ? globalThis.String(object.Reference) : "",
      Extension: isSet(object.Extension) ? globalThis.String(object.Extension) : "",
      Name: isSet(object.Name) ? globalThis.String(object.Name) : undefined,
    };
  },

  toJSON(message: LogoFile): unknown {
    const obj: any = {};
    if (message.Reference !== "") {
      obj.Reference = message.Reference;
    }
    if (message.Extension !== "") {
      obj.Extension = message.Extension;
    }
    if (message.Name !== undefined) {
      obj.Name = message.Name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoFile>, I>>(base?: I): LogoFile {
    return LogoFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoFile>, I>>(object: I): LogoFile {
    const message = createBaseLogoFile();
    message.Reference = object.Reference ?? "";
    message.Extension = object.Extension ?? "";
    message.Name = object.Name ?? undefined;
    return message;
  },
};

function createBaseUserAssetList(): UserAssetList {
  return { AccountID: "", Wallet: "", AssetKey: "", Status: 0, MetaData: undefined, Visible: false };
}

export const UserAssetList = {
  encode(message: UserAssetList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.AccountID !== "") {
      writer.uint32(10).string(message.AccountID);
    }
    if (message.Wallet !== "") {
      writer.uint32(18).string(message.Wallet);
    }
    if (message.AssetKey !== "") {
      writer.uint32(26).string(message.AssetKey);
    }
    if (message.Status !== 0) {
      writer.uint32(32).int32(message.Status);
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(42).fork()).ldelim();
    }
    if (message.Visible !== false) {
      writer.uint32(48).bool(message.Visible);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserAssetList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserAssetList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.AccountID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Wallet = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.AssetKey = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.Visible = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserAssetList {
    return {
      AccountID: isSet(object.AccountID) ? globalThis.String(object.AccountID) : "",
      Wallet: isSet(object.Wallet) ? globalThis.String(object.Wallet) : "",
      AssetKey: isSet(object.AssetKey) ? globalThis.String(object.AssetKey) : "",
      Status: isSet(object.Status) ? userAssetStatusFromJSON(object.Status) : 0,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      Visible: isSet(object.Visible) ? globalThis.Boolean(object.Visible) : false,
    };
  },

  toJSON(message: UserAssetList): unknown {
    const obj: any = {};
    if (message.AccountID !== "") {
      obj.AccountID = message.AccountID;
    }
    if (message.Wallet !== "") {
      obj.Wallet = message.Wallet;
    }
    if (message.AssetKey !== "") {
      obj.AssetKey = message.AssetKey;
    }
    if (message.Status !== 0) {
      obj.Status = userAssetStatusToJSON(message.Status);
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.Visible !== false) {
      obj.Visible = message.Visible;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserAssetList>, I>>(base?: I): UserAssetList {
    return UserAssetList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserAssetList>, I>>(object: I): UserAssetList {
    const message = createBaseUserAssetList();
    message.AccountID = object.AccountID ?? "";
    message.Wallet = object.Wallet ?? "";
    message.AssetKey = object.AssetKey ?? "";
    message.Status = object.Status ?? 0;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.Visible = object.Visible ?? false;
    return message;
  },
};

function createBaseUserAssetLists(): UserAssetLists {
  return { UserAssetLists: [] };
}

export const UserAssetLists = {
  encode(message: UserAssetLists, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.UserAssetLists) {
      UserAssetList.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserAssetLists {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserAssetLists();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.UserAssetLists.push(UserAssetList.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserAssetLists {
    return {
      UserAssetLists: globalThis.Array.isArray(object?.UserAssetLists)
        ? object.UserAssetLists.map((e: any) => UserAssetList.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserAssetLists): unknown {
    const obj: any = {};
    if (message.UserAssetLists?.length) {
      obj.UserAssetLists = message.UserAssetLists.map((e) => UserAssetList.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserAssetLists>, I>>(base?: I): UserAssetLists {
    return UserAssetLists.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserAssetLists>, I>>(object: I): UserAssetLists {
    const message = createBaseUserAssetLists();
    message.UserAssetLists = object.UserAssetLists?.map((e) => UserAssetList.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
