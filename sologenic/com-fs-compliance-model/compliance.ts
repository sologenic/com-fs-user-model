// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.32.0
// source: sologenic/com-fs-compliance-model/compliance.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Audit } from "../com-fs-utils-lib/models/audit/audit";
import { MetaData } from "../com-fs-utils-lib/models/metadata/metadata";

export const protobufPackage = "compliance";

/** Questionnaire types */
export enum QuestionType {
  QUESTION_TYPE_DO_NOT_USE = 0,
  QUESTION_TYPE_RADIO = 1,
  /** QUESTION_TYPE_CHECKBOX - Can be multiple selections */
  QUESTION_TYPE_CHECKBOX = 2,
  QUESTION_TYPE_TEXT = 3,
  UNRECOGNIZED = -1,
}

export function questionTypeFromJSON(object: any): QuestionType {
  switch (object) {
    case 0:
    case "QUESTION_TYPE_DO_NOT_USE":
      return QuestionType.QUESTION_TYPE_DO_NOT_USE;
    case 1:
    case "QUESTION_TYPE_RADIO":
      return QuestionType.QUESTION_TYPE_RADIO;
    case 2:
    case "QUESTION_TYPE_CHECKBOX":
      return QuestionType.QUESTION_TYPE_CHECKBOX;
    case 3:
    case "QUESTION_TYPE_TEXT":
      return QuestionType.QUESTION_TYPE_TEXT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QuestionType.UNRECOGNIZED;
  }
}

export function questionTypeToJSON(object: QuestionType): string {
  switch (object) {
    case QuestionType.QUESTION_TYPE_DO_NOT_USE:
      return "QUESTION_TYPE_DO_NOT_USE";
    case QuestionType.QUESTION_TYPE_RADIO:
      return "QUESTION_TYPE_RADIO";
    case QuestionType.QUESTION_TYPE_CHECKBOX:
      return "QUESTION_TYPE_CHECKBOX";
    case QuestionType.QUESTION_TYPE_TEXT:
      return "QUESTION_TYPE_TEXT";
    case QuestionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ResponseType {
  RESPONSE_TYPE_DO_NOT_USE = 0,
  RESPONSE_TYPE_INT = 1,
  RESPONSE_TYPE_STRING = 2,
  RESPONSE_TYPE_BOOLEAN = 3,
  UNRECOGNIZED = -1,
}

export function responseTypeFromJSON(object: any): ResponseType {
  switch (object) {
    case 0:
    case "RESPONSE_TYPE_DO_NOT_USE":
      return ResponseType.RESPONSE_TYPE_DO_NOT_USE;
    case 1:
    case "RESPONSE_TYPE_INT":
      return ResponseType.RESPONSE_TYPE_INT;
    case 2:
    case "RESPONSE_TYPE_STRING":
      return ResponseType.RESPONSE_TYPE_STRING;
    case 3:
    case "RESPONSE_TYPE_BOOLEAN":
      return ResponseType.RESPONSE_TYPE_BOOLEAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResponseType.UNRECOGNIZED;
  }
}

export function responseTypeToJSON(object: ResponseType): string {
  switch (object) {
    case ResponseType.RESPONSE_TYPE_DO_NOT_USE:
      return "RESPONSE_TYPE_DO_NOT_USE";
    case ResponseType.RESPONSE_TYPE_INT:
      return "RESPONSE_TYPE_INT";
    case ResponseType.RESPONSE_TYPE_STRING:
      return "RESPONSE_TYPE_STRING";
    case ResponseType.RESPONSE_TYPE_BOOLEAN:
      return "RESPONSE_TYPE_BOOLEAN";
    case ResponseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Optionality {
  OPTIONALITY_NONE = 0,
  OPTIONALITY_OPTIONAL = 1,
  OPTIONALITY_REQUIRED = 2,
  /** OPTIONALITY_ON_BOOLEAN_TRUE - If the response type used is boolean, setting this to ON_BOOLEAN_TRUE gives the form implementer clear information on what to do if the boolean is true. */
  OPTIONALITY_ON_BOOLEAN_TRUE = 3,
  UNRECOGNIZED = -1,
}

export function optionalityFromJSON(object: any): Optionality {
  switch (object) {
    case 0:
    case "OPTIONALITY_NONE":
      return Optionality.OPTIONALITY_NONE;
    case 1:
    case "OPTIONALITY_OPTIONAL":
      return Optionality.OPTIONALITY_OPTIONAL;
    case 2:
    case "OPTIONALITY_REQUIRED":
      return Optionality.OPTIONALITY_REQUIRED;
    case 3:
    case "OPTIONALITY_ON_BOOLEAN_TRUE":
      return Optionality.OPTIONALITY_ON_BOOLEAN_TRUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Optionality.UNRECOGNIZED;
  }
}

export function optionalityToJSON(object: Optionality): string {
  switch (object) {
    case Optionality.OPTIONALITY_NONE:
      return "OPTIONALITY_NONE";
    case Optionality.OPTIONALITY_OPTIONAL:
      return "OPTIONALITY_OPTIONAL";
    case Optionality.OPTIONALITY_REQUIRED:
      return "OPTIONALITY_REQUIRED";
    case Optionality.OPTIONALITY_ON_BOOLEAN_TRUE:
      return "OPTIONALITY_ON_BOOLEAN_TRUE";
    case Optionality.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ComplianceStatus {
  COMPLIANCE_STATUS_DO_NOT_USE = 0,
  COMPLIANCE_STATUS_ACTIVE = 1,
  COMPLIANCE_STATUS_INACTIVE = 2,
  UNRECOGNIZED = -1,
}

export function complianceStatusFromJSON(object: any): ComplianceStatus {
  switch (object) {
    case 0:
    case "COMPLIANCE_STATUS_DO_NOT_USE":
      return ComplianceStatus.COMPLIANCE_STATUS_DO_NOT_USE;
    case 1:
    case "COMPLIANCE_STATUS_ACTIVE":
      return ComplianceStatus.COMPLIANCE_STATUS_ACTIVE;
    case 2:
    case "COMPLIANCE_STATUS_INACTIVE":
      return ComplianceStatus.COMPLIANCE_STATUS_INACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComplianceStatus.UNRECOGNIZED;
  }
}

export function complianceStatusToJSON(object: ComplianceStatus): string {
  switch (object) {
    case ComplianceStatus.COMPLIANCE_STATUS_DO_NOT_USE:
      return "COMPLIANCE_STATUS_DO_NOT_USE";
    case ComplianceStatus.COMPLIANCE_STATUS_ACTIVE:
      return "COMPLIANCE_STATUS_ACTIVE";
    case ComplianceStatus.COMPLIANCE_STATUS_INACTIVE:
      return "COMPLIANCE_STATUS_INACTIVE";
    case ComplianceStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Compliance {
  Compliance: ComplianceDetails | undefined;
  MetaData: MetaData | undefined;
  Audit: Audit | undefined;
}

export interface ComplianceDetails {
  /** UUID */
  ComplianceID: string;
  ComplianceName: string;
  ComplianceDescription: string;
  /** UUID, if set the compliance is specific to an organization, otherwise it is global */
  OrganizationID?:
    | string
    | undefined;
  /** Status of the compliance */
  Status: ComplianceStatus;
  Conditions: Condition[];
  Questions: Question[];
}

export interface ComplianceList {
  ComplianceList: Compliance[];
}

export interface Condition {
  /** For now country codes (ISO 3166-1 alpha-3) are supported */
  Jurisdiction: string;
}

export interface Question {
  Question: string;
  QuestionType: QuestionType;
  Required: boolean;
  ResponseType: ResponseType;
  Options: QuestionOption[];
  /** Order of the question in the questionnaire */
  QuestionIndex: number;
  File?: File | undefined;
}

export interface File {
  Description: string;
  Optionality: Optionality;
  /** Hash of the file content, used as file name in the file system */
  Hash?: string | undefined;
}

export interface QuestionOption {
  Label: string;
  /** Order of the option in the question */
  OptionIndex: number;
}

/** Compliance form answer structure */
export interface ComplianceFormAnswer {
  /** UUID - Reference to the compliance form */
  ComplianceID: string;
  /** Answers to individual questions */
  Answers: QuestionAnswer[];
}

export interface QuestionAnswer {
  /** The question text (keeps structure consistent without the need to force static indexes of the question positions) */
  Question: string;
  /** Answer values - single value for radio/text, multiple for checkbox */
  Values: string[];
  /** Files attached to the answer, by repeating the description here, the answers can be rendered in the admin interface even if there are later updates to the questionnaire. */
  Files: File[];
}

function createBaseCompliance(): Compliance {
  return { Compliance: undefined, MetaData: undefined, Audit: undefined };
}

export const Compliance = {
  encode(message: Compliance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Compliance !== undefined) {
      ComplianceDetails.encode(message.Compliance, writer.uint32(10).fork()).ldelim();
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(18).fork()).ldelim();
    }
    if (message.Audit !== undefined) {
      Audit.encode(message.Audit, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Compliance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompliance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Compliance = ComplianceDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Audit = Audit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Compliance {
    return {
      Compliance: isSet(object.Compliance) ? ComplianceDetails.fromJSON(object.Compliance) : undefined,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      Audit: isSet(object.Audit) ? Audit.fromJSON(object.Audit) : undefined,
    };
  },

  toJSON(message: Compliance): unknown {
    const obj: any = {};
    if (message.Compliance !== undefined) {
      obj.Compliance = ComplianceDetails.toJSON(message.Compliance);
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.Audit !== undefined) {
      obj.Audit = Audit.toJSON(message.Audit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Compliance>, I>>(base?: I): Compliance {
    return Compliance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Compliance>, I>>(object: I): Compliance {
    const message = createBaseCompliance();
    message.Compliance = (object.Compliance !== undefined && object.Compliance !== null)
      ? ComplianceDetails.fromPartial(object.Compliance)
      : undefined;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.Audit = (object.Audit !== undefined && object.Audit !== null) ? Audit.fromPartial(object.Audit) : undefined;
    return message;
  },
};

function createBaseComplianceDetails(): ComplianceDetails {
  return {
    ComplianceID: "",
    ComplianceName: "",
    ComplianceDescription: "",
    OrganizationID: undefined,
    Status: 0,
    Conditions: [],
    Questions: [],
  };
}

export const ComplianceDetails = {
  encode(message: ComplianceDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ComplianceID !== "") {
      writer.uint32(10).string(message.ComplianceID);
    }
    if (message.ComplianceName !== "") {
      writer.uint32(18).string(message.ComplianceName);
    }
    if (message.ComplianceDescription !== "") {
      writer.uint32(26).string(message.ComplianceDescription);
    }
    if (message.OrganizationID !== undefined) {
      writer.uint32(34).string(message.OrganizationID);
    }
    if (message.Status !== 0) {
      writer.uint32(40).int32(message.Status);
    }
    for (const v of message.Conditions) {
      Condition.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.Questions) {
      Question.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComplianceDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ComplianceID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ComplianceName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ComplianceDescription = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.Conditions.push(Condition.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.Questions.push(Question.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceDetails {
    return {
      ComplianceID: isSet(object.ComplianceID) ? globalThis.String(object.ComplianceID) : "",
      ComplianceName: isSet(object.ComplianceName) ? globalThis.String(object.ComplianceName) : "",
      ComplianceDescription: isSet(object.ComplianceDescription) ? globalThis.String(object.ComplianceDescription) : "",
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : undefined,
      Status: isSet(object.Status) ? complianceStatusFromJSON(object.Status) : 0,
      Conditions: globalThis.Array.isArray(object?.Conditions)
        ? object.Conditions.map((e: any) => Condition.fromJSON(e))
        : [],
      Questions: globalThis.Array.isArray(object?.Questions)
        ? object.Questions.map((e: any) => Question.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ComplianceDetails): unknown {
    const obj: any = {};
    if (message.ComplianceID !== "") {
      obj.ComplianceID = message.ComplianceID;
    }
    if (message.ComplianceName !== "") {
      obj.ComplianceName = message.ComplianceName;
    }
    if (message.ComplianceDescription !== "") {
      obj.ComplianceDescription = message.ComplianceDescription;
    }
    if (message.OrganizationID !== undefined) {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Status !== 0) {
      obj.Status = complianceStatusToJSON(message.Status);
    }
    if (message.Conditions?.length) {
      obj.Conditions = message.Conditions.map((e) => Condition.toJSON(e));
    }
    if (message.Questions?.length) {
      obj.Questions = message.Questions.map((e) => Question.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComplianceDetails>, I>>(base?: I): ComplianceDetails {
    return ComplianceDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComplianceDetails>, I>>(object: I): ComplianceDetails {
    const message = createBaseComplianceDetails();
    message.ComplianceID = object.ComplianceID ?? "";
    message.ComplianceName = object.ComplianceName ?? "";
    message.ComplianceDescription = object.ComplianceDescription ?? "";
    message.OrganizationID = object.OrganizationID ?? undefined;
    message.Status = object.Status ?? 0;
    message.Conditions = object.Conditions?.map((e) => Condition.fromPartial(e)) || [];
    message.Questions = object.Questions?.map((e) => Question.fromPartial(e)) || [];
    return message;
  },
};

function createBaseComplianceList(): ComplianceList {
  return { ComplianceList: [] };
}

export const ComplianceList = {
  encode(message: ComplianceList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ComplianceList) {
      Compliance.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComplianceList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ComplianceList.push(Compliance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceList {
    return {
      ComplianceList: globalThis.Array.isArray(object?.ComplianceList)
        ? object.ComplianceList.map((e: any) => Compliance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ComplianceList): unknown {
    const obj: any = {};
    if (message.ComplianceList?.length) {
      obj.ComplianceList = message.ComplianceList.map((e) => Compliance.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComplianceList>, I>>(base?: I): ComplianceList {
    return ComplianceList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComplianceList>, I>>(object: I): ComplianceList {
    const message = createBaseComplianceList();
    message.ComplianceList = object.ComplianceList?.map((e) => Compliance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCondition(): Condition {
  return { Jurisdiction: "" };
}

export const Condition = {
  encode(message: Condition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Jurisdiction !== "") {
      writer.uint32(10).string(message.Jurisdiction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Condition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Jurisdiction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition {
    return { Jurisdiction: isSet(object.Jurisdiction) ? globalThis.String(object.Jurisdiction) : "" };
  },

  toJSON(message: Condition): unknown {
    const obj: any = {};
    if (message.Jurisdiction !== "") {
      obj.Jurisdiction = message.Jurisdiction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Condition>, I>>(base?: I): Condition {
    return Condition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Condition>, I>>(object: I): Condition {
    const message = createBaseCondition();
    message.Jurisdiction = object.Jurisdiction ?? "";
    return message;
  },
};

function createBaseQuestion(): Question {
  return {
    Question: "",
    QuestionType: 0,
    Required: false,
    ResponseType: 0,
    Options: [],
    QuestionIndex: 0,
    File: undefined,
  };
}

export const Question = {
  encode(message: Question, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Question !== "") {
      writer.uint32(10).string(message.Question);
    }
    if (message.QuestionType !== 0) {
      writer.uint32(16).int32(message.QuestionType);
    }
    if (message.Required !== false) {
      writer.uint32(24).bool(message.Required);
    }
    if (message.ResponseType !== 0) {
      writer.uint32(32).int32(message.ResponseType);
    }
    for (const v of message.Options) {
      QuestionOption.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.QuestionIndex !== 0) {
      writer.uint32(48).int32(message.QuestionIndex);
    }
    if (message.File !== undefined) {
      File.encode(message.File, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Question {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Question = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.QuestionType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Required = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ResponseType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Options.push(QuestionOption.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.QuestionIndex = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.File = File.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Question {
    return {
      Question: isSet(object.Question) ? globalThis.String(object.Question) : "",
      QuestionType: isSet(object.QuestionType) ? questionTypeFromJSON(object.QuestionType) : 0,
      Required: isSet(object.Required) ? globalThis.Boolean(object.Required) : false,
      ResponseType: isSet(object.ResponseType) ? responseTypeFromJSON(object.ResponseType) : 0,
      Options: globalThis.Array.isArray(object?.Options)
        ? object.Options.map((e: any) => QuestionOption.fromJSON(e))
        : [],
      QuestionIndex: isSet(object.QuestionIndex) ? globalThis.Number(object.QuestionIndex) : 0,
      File: isSet(object.File) ? File.fromJSON(object.File) : undefined,
    };
  },

  toJSON(message: Question): unknown {
    const obj: any = {};
    if (message.Question !== "") {
      obj.Question = message.Question;
    }
    if (message.QuestionType !== 0) {
      obj.QuestionType = questionTypeToJSON(message.QuestionType);
    }
    if (message.Required !== false) {
      obj.Required = message.Required;
    }
    if (message.ResponseType !== 0) {
      obj.ResponseType = responseTypeToJSON(message.ResponseType);
    }
    if (message.Options?.length) {
      obj.Options = message.Options.map((e) => QuestionOption.toJSON(e));
    }
    if (message.QuestionIndex !== 0) {
      obj.QuestionIndex = Math.round(message.QuestionIndex);
    }
    if (message.File !== undefined) {
      obj.File = File.toJSON(message.File);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Question>, I>>(base?: I): Question {
    return Question.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Question>, I>>(object: I): Question {
    const message = createBaseQuestion();
    message.Question = object.Question ?? "";
    message.QuestionType = object.QuestionType ?? 0;
    message.Required = object.Required ?? false;
    message.ResponseType = object.ResponseType ?? 0;
    message.Options = object.Options?.map((e) => QuestionOption.fromPartial(e)) || [];
    message.QuestionIndex = object.QuestionIndex ?? 0;
    message.File = (object.File !== undefined && object.File !== null) ? File.fromPartial(object.File) : undefined;
    return message;
  },
};

function createBaseFile(): File {
  return { Description: "", Optionality: 0, Hash: undefined };
}

export const File = {
  encode(message: File, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Description !== "") {
      writer.uint32(10).string(message.Description);
    }
    if (message.Optionality !== 0) {
      writer.uint32(16).int32(message.Optionality);
    }
    if (message.Hash !== undefined) {
      writer.uint32(26).string(message.Hash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): File {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Description = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Optionality = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Hash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): File {
    return {
      Description: isSet(object.Description) ? globalThis.String(object.Description) : "",
      Optionality: isSet(object.Optionality) ? optionalityFromJSON(object.Optionality) : 0,
      Hash: isSet(object.Hash) ? globalThis.String(object.Hash) : undefined,
    };
  },

  toJSON(message: File): unknown {
    const obj: any = {};
    if (message.Description !== "") {
      obj.Description = message.Description;
    }
    if (message.Optionality !== 0) {
      obj.Optionality = optionalityToJSON(message.Optionality);
    }
    if (message.Hash !== undefined) {
      obj.Hash = message.Hash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<File>, I>>(base?: I): File {
    return File.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<File>, I>>(object: I): File {
    const message = createBaseFile();
    message.Description = object.Description ?? "";
    message.Optionality = object.Optionality ?? 0;
    message.Hash = object.Hash ?? undefined;
    return message;
  },
};

function createBaseQuestionOption(): QuestionOption {
  return { Label: "", OptionIndex: 0 };
}

export const QuestionOption = {
  encode(message: QuestionOption, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Label !== "") {
      writer.uint32(10).string(message.Label);
    }
    if (message.OptionIndex !== 0) {
      writer.uint32(16).int32(message.OptionIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuestionOption {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Label = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.OptionIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionOption {
    return {
      Label: isSet(object.Label) ? globalThis.String(object.Label) : "",
      OptionIndex: isSet(object.OptionIndex) ? globalThis.Number(object.OptionIndex) : 0,
    };
  },

  toJSON(message: QuestionOption): unknown {
    const obj: any = {};
    if (message.Label !== "") {
      obj.Label = message.Label;
    }
    if (message.OptionIndex !== 0) {
      obj.OptionIndex = Math.round(message.OptionIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuestionOption>, I>>(base?: I): QuestionOption {
    return QuestionOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuestionOption>, I>>(object: I): QuestionOption {
    const message = createBaseQuestionOption();
    message.Label = object.Label ?? "";
    message.OptionIndex = object.OptionIndex ?? 0;
    return message;
  },
};

function createBaseComplianceFormAnswer(): ComplianceFormAnswer {
  return { ComplianceID: "", Answers: [] };
}

export const ComplianceFormAnswer = {
  encode(message: ComplianceFormAnswer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ComplianceID !== "") {
      writer.uint32(10).string(message.ComplianceID);
    }
    for (const v of message.Answers) {
      QuestionAnswer.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComplianceFormAnswer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceFormAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ComplianceID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Answers.push(QuestionAnswer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceFormAnswer {
    return {
      ComplianceID: isSet(object.ComplianceID) ? globalThis.String(object.ComplianceID) : "",
      Answers: globalThis.Array.isArray(object?.Answers)
        ? object.Answers.map((e: any) => QuestionAnswer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ComplianceFormAnswer): unknown {
    const obj: any = {};
    if (message.ComplianceID !== "") {
      obj.ComplianceID = message.ComplianceID;
    }
    if (message.Answers?.length) {
      obj.Answers = message.Answers.map((e) => QuestionAnswer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComplianceFormAnswer>, I>>(base?: I): ComplianceFormAnswer {
    return ComplianceFormAnswer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComplianceFormAnswer>, I>>(object: I): ComplianceFormAnswer {
    const message = createBaseComplianceFormAnswer();
    message.ComplianceID = object.ComplianceID ?? "";
    message.Answers = object.Answers?.map((e) => QuestionAnswer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuestionAnswer(): QuestionAnswer {
  return { Question: "", Values: [], Files: [] };
}

export const QuestionAnswer = {
  encode(message: QuestionAnswer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Question !== "") {
      writer.uint32(10).string(message.Question);
    }
    for (const v of message.Values) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.Files) {
      File.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuestionAnswer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Question = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Values.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Files.push(File.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnswer {
    return {
      Question: isSet(object.Question) ? globalThis.String(object.Question) : "",
      Values: globalThis.Array.isArray(object?.Values) ? object.Values.map((e: any) => globalThis.String(e)) : [],
      Files: globalThis.Array.isArray(object?.Files) ? object.Files.map((e: any) => File.fromJSON(e)) : [],
    };
  },

  toJSON(message: QuestionAnswer): unknown {
    const obj: any = {};
    if (message.Question !== "") {
      obj.Question = message.Question;
    }
    if (message.Values?.length) {
      obj.Values = message.Values;
    }
    if (message.Files?.length) {
      obj.Files = message.Files.map((e) => File.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuestionAnswer>, I>>(base?: I): QuestionAnswer {
    return QuestionAnswer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuestionAnswer>, I>>(object: I): QuestionAnswer {
    const message = createBaseQuestionAnswer();
    message.Question = object.Question ?? "";
    message.Values = object.Values?.map((e) => e) || [];
    message.Files = object.Files?.map((e) => File.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
