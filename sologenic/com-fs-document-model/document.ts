// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.32.0
// source: sologenic/com-fs-document-model/document.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Audit } from "../com-fs-utils-lib/models/audit/audit";
import { MetaData } from "../com-fs-utils-lib/models/metadata/metadata";

export const protobufPackage = "document";

export enum DocumentStatus {
  NOT_USED_STATUS = 0,
  /** UNPUBLISHED - Document is unpublished and in draft state */
  UNPUBLISHED = 1,
  /** ACTIVE - Document is active and required for users */
  ACTIVE = 2,
  /** OUTDATED - Document is outdated and no longer required */
  OUTDATED = 3,
  UNRECOGNIZED = -1,
}

export function documentStatusFromJSON(object: any): DocumentStatus {
  switch (object) {
    case 0:
    case "NOT_USED_STATUS":
      return DocumentStatus.NOT_USED_STATUS;
    case 1:
    case "UNPUBLISHED":
      return DocumentStatus.UNPUBLISHED;
    case 2:
    case "ACTIVE":
      return DocumentStatus.ACTIVE;
    case 3:
    case "OUTDATED":
      return DocumentStatus.OUTDATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DocumentStatus.UNRECOGNIZED;
  }
}

export function documentStatusToJSON(object: DocumentStatus): string {
  switch (object) {
    case DocumentStatus.NOT_USED_STATUS:
      return "NOT_USED_STATUS";
    case DocumentStatus.UNPUBLISHED:
      return "UNPUBLISHED";
    case DocumentStatus.ACTIVE:
      return "ACTIVE";
    case DocumentStatus.OUTDATED:
      return "OUTDATED";
    case DocumentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DocumentState {
  NOT_USED_STATE = 0,
  TO_BE_SIGNED = 1,
  SIGNED = 2,
  DISPLAY_ONLY = 3,
  UNRECOGNIZED = -1,
}

export function documentStateFromJSON(object: any): DocumentState {
  switch (object) {
    case 0:
    case "NOT_USED_STATE":
      return DocumentState.NOT_USED_STATE;
    case 1:
    case "TO_BE_SIGNED":
      return DocumentState.TO_BE_SIGNED;
    case 2:
    case "SIGNED":
      return DocumentState.SIGNED;
    case 3:
    case "DISPLAY_ONLY":
      return DocumentState.DISPLAY_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DocumentState.UNRECOGNIZED;
  }
}

export function documentStateToJSON(object: DocumentState): string {
  switch (object) {
    case DocumentState.NOT_USED_STATE:
      return "NOT_USED_STATE";
    case DocumentState.TO_BE_SIGNED:
      return "TO_BE_SIGNED";
    case DocumentState.SIGNED:
      return "SIGNED";
    case DocumentState.DISPLAY_ONLY:
      return "DISPLAY_ONLY";
    case DocumentState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Document {
  Document:
    | DocumentDetails
    | undefined;
  /** Network is not to be assigned (documents are network agnostic) */
  MetaData: MetaData | undefined;
  Audit: Audit | undefined;
}

/** Key format: OrganizationID_File.MD5SUM */
export interface DocumentDetails {
  OrganizationID: string;
  Name: string;
  /** Latest version of the document */
  Version: string;
  Description: string;
  File:
    | File
    | undefined;
  /** if false, the document is for display/reference only */
  SignatureRequired: boolean;
  Status: DocumentStatus;
}

export interface File {
  /** The reference to the file */
  Reference: string;
  Extension: string;
  /** User defined name of the file, used as a "description" and not to reference the file */
  Name?:
    | string
    | undefined;
  /** MD5 checksum of the file for integrity verification */
  MD5SUM: string;
}

export interface Documents {
  Documents: Document[];
  Offset: number;
}

/** UserDocumentCompliance is embedded in User object to track user document compliance */
export interface UserDocumentCompliance {
  SignedDocuments: SignedDocument[];
}

export interface SignedDocument {
  Name: string;
  /** The version of the document that was signed. This may differ from the current/latest version. */
  SignedVersion: string;
  DocumentState: DocumentState;
  SignedAt:
    | Date
    | undefined;
  /** MD5 checksum of the file that was signed */
  FileMD5SUM: string;
}

function createBaseDocument(): Document {
  return { Document: undefined, MetaData: undefined, Audit: undefined };
}

export const Document = {
  encode(message: Document, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Document !== undefined) {
      DocumentDetails.encode(message.Document, writer.uint32(10).fork()).ldelim();
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(18).fork()).ldelim();
    }
    if (message.Audit !== undefined) {
      Audit.encode(message.Audit, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Document {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Document = DocumentDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Audit = Audit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document {
    return {
      Document: isSet(object.Document) ? DocumentDetails.fromJSON(object.Document) : undefined,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      Audit: isSet(object.Audit) ? Audit.fromJSON(object.Audit) : undefined,
    };
  },

  toJSON(message: Document): unknown {
    const obj: any = {};
    if (message.Document !== undefined) {
      obj.Document = DocumentDetails.toJSON(message.Document);
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.Audit !== undefined) {
      obj.Audit = Audit.toJSON(message.Audit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Document>, I>>(base?: I): Document {
    return Document.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Document>, I>>(object: I): Document {
    const message = createBaseDocument();
    message.Document = (object.Document !== undefined && object.Document !== null)
      ? DocumentDetails.fromPartial(object.Document)
      : undefined;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.Audit = (object.Audit !== undefined && object.Audit !== null) ? Audit.fromPartial(object.Audit) : undefined;
    return message;
  },
};

function createBaseDocumentDetails(): DocumentDetails {
  return {
    OrganizationID: "",
    Name: "",
    Version: "",
    Description: "",
    File: undefined,
    SignatureRequired: false,
    Status: 0,
  };
}

export const DocumentDetails = {
  encode(message: DocumentDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.OrganizationID !== "") {
      writer.uint32(10).string(message.OrganizationID);
    }
    if (message.Name !== "") {
      writer.uint32(18).string(message.Name);
    }
    if (message.Version !== "") {
      writer.uint32(26).string(message.Version);
    }
    if (message.Description !== "") {
      writer.uint32(34).string(message.Description);
    }
    if (message.File !== undefined) {
      File.encode(message.File, writer.uint32(42).fork()).ldelim();
    }
    if (message.SignatureRequired !== false) {
      writer.uint32(48).bool(message.SignatureRequired);
    }
    if (message.Status !== 0) {
      writer.uint32(56).int32(message.Status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Version = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.File = File.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.SignatureRequired = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentDetails {
    return {
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Name: isSet(object.Name) ? globalThis.String(object.Name) : "",
      Version: isSet(object.Version) ? globalThis.String(object.Version) : "",
      Description: isSet(object.Description) ? globalThis.String(object.Description) : "",
      File: isSet(object.File) ? File.fromJSON(object.File) : undefined,
      SignatureRequired: isSet(object.SignatureRequired) ? globalThis.Boolean(object.SignatureRequired) : false,
      Status: isSet(object.Status) ? documentStatusFromJSON(object.Status) : 0,
    };
  },

  toJSON(message: DocumentDetails): unknown {
    const obj: any = {};
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Name !== "") {
      obj.Name = message.Name;
    }
    if (message.Version !== "") {
      obj.Version = message.Version;
    }
    if (message.Description !== "") {
      obj.Description = message.Description;
    }
    if (message.File !== undefined) {
      obj.File = File.toJSON(message.File);
    }
    if (message.SignatureRequired !== false) {
      obj.SignatureRequired = message.SignatureRequired;
    }
    if (message.Status !== 0) {
      obj.Status = documentStatusToJSON(message.Status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentDetails>, I>>(base?: I): DocumentDetails {
    return DocumentDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentDetails>, I>>(object: I): DocumentDetails {
    const message = createBaseDocumentDetails();
    message.OrganizationID = object.OrganizationID ?? "";
    message.Name = object.Name ?? "";
    message.Version = object.Version ?? "";
    message.Description = object.Description ?? "";
    message.File = (object.File !== undefined && object.File !== null) ? File.fromPartial(object.File) : undefined;
    message.SignatureRequired = object.SignatureRequired ?? false;
    message.Status = object.Status ?? 0;
    return message;
  },
};

function createBaseFile(): File {
  return { Reference: "", Extension: "", Name: undefined, MD5SUM: "" };
}

export const File = {
  encode(message: File, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Reference !== "") {
      writer.uint32(10).string(message.Reference);
    }
    if (message.Extension !== "") {
      writer.uint32(18).string(message.Extension);
    }
    if (message.Name !== undefined) {
      writer.uint32(26).string(message.Name);
    }
    if (message.MD5SUM !== "") {
      writer.uint32(34).string(message.MD5SUM);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): File {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Reference = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Extension = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.MD5SUM = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): File {
    return {
      Reference: isSet(object.Reference) ? globalThis.String(object.Reference) : "",
      Extension: isSet(object.Extension) ? globalThis.String(object.Extension) : "",
      Name: isSet(object.Name) ? globalThis.String(object.Name) : undefined,
      MD5SUM: isSet(object.MD5SUM) ? globalThis.String(object.MD5SUM) : "",
    };
  },

  toJSON(message: File): unknown {
    const obj: any = {};
    if (message.Reference !== "") {
      obj.Reference = message.Reference;
    }
    if (message.Extension !== "") {
      obj.Extension = message.Extension;
    }
    if (message.Name !== undefined) {
      obj.Name = message.Name;
    }
    if (message.MD5SUM !== "") {
      obj.MD5SUM = message.MD5SUM;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<File>, I>>(base?: I): File {
    return File.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<File>, I>>(object: I): File {
    const message = createBaseFile();
    message.Reference = object.Reference ?? "";
    message.Extension = object.Extension ?? "";
    message.Name = object.Name ?? undefined;
    message.MD5SUM = object.MD5SUM ?? "";
    return message;
  },
};

function createBaseDocuments(): Documents {
  return { Documents: [], Offset: 0 };
}

export const Documents = {
  encode(message: Documents, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Documents) {
      Document.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.Offset !== 0) {
      writer.uint32(16).int32(message.Offset);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Documents {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocuments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Documents.push(Document.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Offset = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Documents {
    return {
      Documents: globalThis.Array.isArray(object?.Documents)
        ? object.Documents.map((e: any) => Document.fromJSON(e))
        : [],
      Offset: isSet(object.Offset) ? globalThis.Number(object.Offset) : 0,
    };
  },

  toJSON(message: Documents): unknown {
    const obj: any = {};
    if (message.Documents?.length) {
      obj.Documents = message.Documents.map((e) => Document.toJSON(e));
    }
    if (message.Offset !== 0) {
      obj.Offset = Math.round(message.Offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Documents>, I>>(base?: I): Documents {
    return Documents.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Documents>, I>>(object: I): Documents {
    const message = createBaseDocuments();
    message.Documents = object.Documents?.map((e) => Document.fromPartial(e)) || [];
    message.Offset = object.Offset ?? 0;
    return message;
  },
};

function createBaseUserDocumentCompliance(): UserDocumentCompliance {
  return { SignedDocuments: [] };
}

export const UserDocumentCompliance = {
  encode(message: UserDocumentCompliance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.SignedDocuments) {
      SignedDocument.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserDocumentCompliance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDocumentCompliance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.SignedDocuments.push(SignedDocument.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDocumentCompliance {
    return {
      SignedDocuments: globalThis.Array.isArray(object?.SignedDocuments)
        ? object.SignedDocuments.map((e: any) => SignedDocument.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserDocumentCompliance): unknown {
    const obj: any = {};
    if (message.SignedDocuments?.length) {
      obj.SignedDocuments = message.SignedDocuments.map((e) => SignedDocument.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserDocumentCompliance>, I>>(base?: I): UserDocumentCompliance {
    return UserDocumentCompliance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserDocumentCompliance>, I>>(object: I): UserDocumentCompliance {
    const message = createBaseUserDocumentCompliance();
    message.SignedDocuments = object.SignedDocuments?.map((e) => SignedDocument.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSignedDocument(): SignedDocument {
  return { Name: "", SignedVersion: "", DocumentState: 0, SignedAt: undefined, FileMD5SUM: "" };
}

export const SignedDocument = {
  encode(message: SignedDocument, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Name !== "") {
      writer.uint32(10).string(message.Name);
    }
    if (message.SignedVersion !== "") {
      writer.uint32(18).string(message.SignedVersion);
    }
    if (message.DocumentState !== 0) {
      writer.uint32(24).int32(message.DocumentState);
    }
    if (message.SignedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.SignedAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.FileMD5SUM !== "") {
      writer.uint32(42).string(message.FileMD5SUM);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedDocument {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.SignedVersion = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.DocumentState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.SignedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.FileMD5SUM = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedDocument {
    return {
      Name: isSet(object.Name) ? globalThis.String(object.Name) : "",
      SignedVersion: isSet(object.SignedVersion) ? globalThis.String(object.SignedVersion) : "",
      DocumentState: isSet(object.DocumentState) ? documentStateFromJSON(object.DocumentState) : 0,
      SignedAt: isSet(object.SignedAt) ? fromJsonTimestamp(object.SignedAt) : undefined,
      FileMD5SUM: isSet(object.FileMD5SUM) ? globalThis.String(object.FileMD5SUM) : "",
    };
  },

  toJSON(message: SignedDocument): unknown {
    const obj: any = {};
    if (message.Name !== "") {
      obj.Name = message.Name;
    }
    if (message.SignedVersion !== "") {
      obj.SignedVersion = message.SignedVersion;
    }
    if (message.DocumentState !== 0) {
      obj.DocumentState = documentStateToJSON(message.DocumentState);
    }
    if (message.SignedAt !== undefined) {
      obj.SignedAt = message.SignedAt.toISOString();
    }
    if (message.FileMD5SUM !== "") {
      obj.FileMD5SUM = message.FileMD5SUM;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignedDocument>, I>>(base?: I): SignedDocument {
    return SignedDocument.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignedDocument>, I>>(object: I): SignedDocument {
    const message = createBaseSignedDocument();
    message.Name = object.Name ?? "";
    message.SignedVersion = object.SignedVersion ?? "";
    message.DocumentState = object.DocumentState ?? 0;
    message.SignedAt = object.SignedAt ?? undefined;
    message.FileMD5SUM = object.FileMD5SUM ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
