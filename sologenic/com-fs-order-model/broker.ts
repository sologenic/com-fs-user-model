// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.32.0
// source: sologenic/com-fs-order-model/broker.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { AssetType, assetTypeFromJSON, assetTypeToJSON } from "../com-fs-asset-model/asset";
import { Decimal } from "../com-fs-utils-lib/go/decimal/decimal";
import { CommissionSettings } from "../com-fs-utils-lib/models/commission/commission";
import { Network, networkFromJSON, networkToJSON } from "../com-fs-utils-lib/models/metadata/metadata";
import {
  OrderType,
  orderTypeFromJSON,
  orderTypeToJSON,
  ProcessInfo,
  TimeInForce,
  timeInForceFromJSON,
  timeInForceToJSON,
} from "../com-fs-utils-lib/models/order-properties/order-properties";

export const protobufPackage = "order";

export enum ClearingBroker {
  NOT_USED_CLEARING_BROKER = 0,
  ALPACA = 1,
  RQD = 2,
  UNRECOGNIZED = -1,
}

export function clearingBrokerFromJSON(object: any): ClearingBroker {
  switch (object) {
    case 0:
    case "NOT_USED_CLEARING_BROKER":
      return ClearingBroker.NOT_USED_CLEARING_BROKER;
    case 1:
    case "ALPACA":
      return ClearingBroker.ALPACA;
    case 2:
    case "RQD":
      return ClearingBroker.RQD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ClearingBroker.UNRECOGNIZED;
  }
}

export function clearingBrokerToJSON(object: ClearingBroker): string {
  switch (object) {
    case ClearingBroker.NOT_USED_CLEARING_BROKER:
      return "NOT_USED_CLEARING_BROKER";
    case ClearingBroker.ALPACA:
      return "ALPACA";
    case ClearingBroker.RQD:
      return "RQD";
    case ClearingBroker.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TradeType {
  NOT_APPLICABLE_TRADE_TYPE = 0,
  MARKET = 1,
  LIMIT = 2,
  STOP = 3,
  STOP_LIMIT = 4,
  OPEN_CLOSE_AUCTION = 5,
  BRACKET = 6,
  /** ONE_CANCELS_OTHER - OCO */
  ONE_CANCELS_OTHER = 7,
  /** ONE_TRIGGERS_OTHER - OTO */
  ONE_TRIGGERS_OTHER = 8,
  TRAILING_STOP = 9,
  UNRECOGNIZED = -1,
}

export function tradeTypeFromJSON(object: any): TradeType {
  switch (object) {
    case 0:
    case "NOT_APPLICABLE_TRADE_TYPE":
      return TradeType.NOT_APPLICABLE_TRADE_TYPE;
    case 1:
    case "MARKET":
      return TradeType.MARKET;
    case 2:
    case "LIMIT":
      return TradeType.LIMIT;
    case 3:
    case "STOP":
      return TradeType.STOP;
    case 4:
    case "STOP_LIMIT":
      return TradeType.STOP_LIMIT;
    case 5:
    case "OPEN_CLOSE_AUCTION":
      return TradeType.OPEN_CLOSE_AUCTION;
    case 6:
    case "BRACKET":
      return TradeType.BRACKET;
    case 7:
    case "ONE_CANCELS_OTHER":
      return TradeType.ONE_CANCELS_OTHER;
    case 8:
    case "ONE_TRIGGERS_OTHER":
      return TradeType.ONE_TRIGGERS_OTHER;
    case 9:
    case "TRAILING_STOP":
      return TradeType.TRAILING_STOP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TradeType.UNRECOGNIZED;
  }
}

export function tradeTypeToJSON(object: TradeType): string {
  switch (object) {
    case TradeType.NOT_APPLICABLE_TRADE_TYPE:
      return "NOT_APPLICABLE_TRADE_TYPE";
    case TradeType.MARKET:
      return "MARKET";
    case TradeType.LIMIT:
      return "LIMIT";
    case TradeType.STOP:
      return "STOP";
    case TradeType.STOP_LIMIT:
      return "STOP_LIMIT";
    case TradeType.OPEN_CLOSE_AUCTION:
      return "OPEN_CLOSE_AUCTION";
    case TradeType.BRACKET:
      return "BRACKET";
    case TradeType.ONE_CANCELS_OTHER:
      return "ONE_CANCELS_OTHER";
    case TradeType.ONE_TRIGGERS_OTHER:
      return "ONE_TRIGGERS_OTHER";
    case TradeType.TRAILING_STOP:
      return "TRAILING_STOP";
    case TradeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderClass {
  NOT_USED_ORDER_CLASS = 0,
  ORDER_CLASS_SIMPLE = 1,
  ORDER_CLASS_BRACKET = 2,
  /** ORDER_CLASS_ONE_CANCELS_OTHER - OCO */
  ORDER_CLASS_ONE_CANCELS_OTHER = 3,
  /** ORDER_CLASS_ONE_TRIGGERS_OTHER - OTO */
  ORDER_CLASS_ONE_TRIGGERS_OTHER = 4,
  UNRECOGNIZED = -1,
}

export function orderClassFromJSON(object: any): OrderClass {
  switch (object) {
    case 0:
    case "NOT_USED_ORDER_CLASS":
      return OrderClass.NOT_USED_ORDER_CLASS;
    case 1:
    case "ORDER_CLASS_SIMPLE":
      return OrderClass.ORDER_CLASS_SIMPLE;
    case 2:
    case "ORDER_CLASS_BRACKET":
      return OrderClass.ORDER_CLASS_BRACKET;
    case 3:
    case "ORDER_CLASS_ONE_CANCELS_OTHER":
      return OrderClass.ORDER_CLASS_ONE_CANCELS_OTHER;
    case 4:
    case "ORDER_CLASS_ONE_TRIGGERS_OTHER":
      return OrderClass.ORDER_CLASS_ONE_TRIGGERS_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderClass.UNRECOGNIZED;
  }
}

export function orderClassToJSON(object: OrderClass): string {
  switch (object) {
    case OrderClass.NOT_USED_ORDER_CLASS:
      return "NOT_USED_ORDER_CLASS";
    case OrderClass.ORDER_CLASS_SIMPLE:
      return "ORDER_CLASS_SIMPLE";
    case OrderClass.ORDER_CLASS_BRACKET:
      return "ORDER_CLASS_BRACKET";
    case OrderClass.ORDER_CLASS_ONE_CANCELS_OTHER:
      return "ORDER_CLASS_ONE_CANCELS_OTHER";
    case OrderClass.ORDER_CLASS_ONE_TRIGGERS_OTHER:
      return "ORDER_CLASS_ONE_TRIGGERS_OTHER";
    case OrderClass.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BrokerOrderStatus {
  NOT_USED_ORDER_STATUS = 0,
  /** PENDING_NEW - common statuses */
  PENDING_NEW = 1,
  /** NEW - the order has been received by the broker, and routed to exchanges for execution. */
  NEW = 2,
  /** PARTIALLY_FILLED - the order has been partially filled. */
  PARTIALLY_FILLED = 3,
  /** FILLED - the order has been filled, and no further updates will occur for the order. */
  FILLED = 4,
  /** DONE_FOR_DAY - the order is done executing for the day, and will not receive further updates until the next trading day. */
  DONE_FOR_DAY = 5,
  /** CANCELED - the order has been canceled, and no further updates will occur for the order. This can be either due to a cancel request by the user, or the order has been canceled by the exchanges due to its time-in-force. */
  CANCELED = 6,
  /** EXPIRED - the order has expired, and no further updates will occur for the order. */
  EXPIRED = 7,
  /** PENDING_CANCEL - uncommon statuses */
  PENDING_CANCEL = 8,
  /** ACCEPTED - the order has been received by the broker, but hasnâ€™t yet been routed to the execution venue. */
  ACCEPTED = 9,
  /** ACCEPTED_FOR_BIDDING - the order has been received by exchanges, and is evaluated for pricing. */
  ACCEPTED_FOR_BIDDING = 10,
  /** STOPPED - the order has been stopped, and a trade is guaranteed for the order, usually at a stated price or better, but has not yet occurred. */
  STOPPED = 11,
  /** REJECTED - the order has been rejected, and no further updates will occur for the order. */
  REJECTED = 12,
  /** SUSPENDED - the order has been suspended, and is not eligible for trading. */
  SUSPENDED = 13,
  /** CALCULATED - the order has been completed for the day (either filled or done for day), but remaining settlement calculations are still pending. */
  CALCULATED = 14,
  UNRECOGNIZED = -1,
}

export function brokerOrderStatusFromJSON(object: any): BrokerOrderStatus {
  switch (object) {
    case 0:
    case "NOT_USED_ORDER_STATUS":
      return BrokerOrderStatus.NOT_USED_ORDER_STATUS;
    case 1:
    case "PENDING_NEW":
      return BrokerOrderStatus.PENDING_NEW;
    case 2:
    case "NEW":
      return BrokerOrderStatus.NEW;
    case 3:
    case "PARTIALLY_FILLED":
      return BrokerOrderStatus.PARTIALLY_FILLED;
    case 4:
    case "FILLED":
      return BrokerOrderStatus.FILLED;
    case 5:
    case "DONE_FOR_DAY":
      return BrokerOrderStatus.DONE_FOR_DAY;
    case 6:
    case "CANCELED":
      return BrokerOrderStatus.CANCELED;
    case 7:
    case "EXPIRED":
      return BrokerOrderStatus.EXPIRED;
    case 8:
    case "PENDING_CANCEL":
      return BrokerOrderStatus.PENDING_CANCEL;
    case 9:
    case "ACCEPTED":
      return BrokerOrderStatus.ACCEPTED;
    case 10:
    case "ACCEPTED_FOR_BIDDING":
      return BrokerOrderStatus.ACCEPTED_FOR_BIDDING;
    case 11:
    case "STOPPED":
      return BrokerOrderStatus.STOPPED;
    case 12:
    case "REJECTED":
      return BrokerOrderStatus.REJECTED;
    case 13:
    case "SUSPENDED":
      return BrokerOrderStatus.SUSPENDED;
    case 14:
    case "CALCULATED":
      return BrokerOrderStatus.CALCULATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BrokerOrderStatus.UNRECOGNIZED;
  }
}

export function brokerOrderStatusToJSON(object: BrokerOrderStatus): string {
  switch (object) {
    case BrokerOrderStatus.NOT_USED_ORDER_STATUS:
      return "NOT_USED_ORDER_STATUS";
    case BrokerOrderStatus.PENDING_NEW:
      return "PENDING_NEW";
    case BrokerOrderStatus.NEW:
      return "NEW";
    case BrokerOrderStatus.PARTIALLY_FILLED:
      return "PARTIALLY_FILLED";
    case BrokerOrderStatus.FILLED:
      return "FILLED";
    case BrokerOrderStatus.DONE_FOR_DAY:
      return "DONE_FOR_DAY";
    case BrokerOrderStatus.CANCELED:
      return "CANCELED";
    case BrokerOrderStatus.EXPIRED:
      return "EXPIRED";
    case BrokerOrderStatus.PENDING_CANCEL:
      return "PENDING_CANCEL";
    case BrokerOrderStatus.ACCEPTED:
      return "ACCEPTED";
    case BrokerOrderStatus.ACCEPTED_FOR_BIDDING:
      return "ACCEPTED_FOR_BIDDING";
    case BrokerOrderStatus.STOPPED:
      return "STOPPED";
    case BrokerOrderStatus.REJECTED:
      return "REJECTED";
    case BrokerOrderStatus.SUSPENDED:
      return "SUSPENDED";
    case BrokerOrderStatus.CALCULATED:
      return "CALCULATED";
    case BrokerOrderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Key orderID-SmartContractAddr-network (is as unique identifier for the order in message to the broker) */
export interface BrokerOrderDetails {
  /** auto generated ID from the broker */
  BrokerAssignedID: string;
  /** unique identifier for the order in message to the broker, value is from the key function */
  ClientOrderID: ClientOrderID | undefined;
  SubmittedAt: Date | undefined;
  FilledAt?: Date | undefined;
  ExpiredAt?: Date | undefined;
  CancelledAt?: Date | undefined;
  FailedAt?: Date | undefined;
  AssetID: string;
  Symbol: string;
  /** Also called AssetType in the asset model */
  AssetClass: AssetType;
  OrderClass: OrderClass;
  Type: TradeType;
  Side: OrderType;
  TimeInForce: TimeInForce;
  /** Notional and Qty are optional as one can be null if the other is present. However, both cannot be null or present at the same time. */
  Notional?: Decimal | undefined;
  OrderQty?:
    | Decimal
    | undefined;
  /** defaults to 0, updated as previous `FilledQty` + `PartialQty` */
  FilledQty: Decimal | undefined;
  FilledAvgPrice?: Decimal | undefined;
  LimitPrice?: Decimal | undefined;
  StopPrice?: Decimal | undefined;
  TrailPrice?: Decimal | undefined;
  TrailPercent?:
    | Decimal
    | undefined;
  /** High Water Mark, used for trailing stop orders */
  HWM?:
    | Decimal
    | undefined;
  /** defaults to false, High Water Mark is used for trailing stop orders */
  ExtendedHours: boolean;
  CreatedAt: Date | undefined;
  UpdatedAt?:
    | Date
    | undefined;
  /** status of the order in exchange */
  Status: BrokerOrderStatus;
  /** Since all orders will flow through Sologenic's custodial account, this will represent the total count of all shares on our platform. */
  TotalPosition?:
    | Decimal
    | undefined;
  /**
   * Represents the price of the order processed at the time of partial fill. For example, if a 3 step partial fill occurs for an order at prices $1, $1.1 and $0.9,
   * the `PartialPrice` will be $1, $1.1 and $0.9 respectively. The average of these prices will be the `FilledAvgPrice`.
   */
  PartialPrice?:
    | Decimal
    | undefined;
  /**
   * Represents the partial order processed at the time of partial fill.
   * For example, if a order for 10 shares is partially filled with 5, 3 and 2 shares, the `PartialQty` will be 5, 3 and 2 respectively.
   */
  PartialQty?:
    | Decimal
    | undefined;
  /** Bookkeeping: did we process this event from the broker order log? */
  ProcessInfo?:
    | ProcessInfo
    | undefined;
  /** ID used by logs to identify the instance where the log was created/ processed */
  InstanceID?:
    | string
    | undefined;
  /** Broker that cleared the order, e.g. Alpaca, RQD, etc. */
  ClearingBroker: ClearingBroker;
  /**
   * SSE Event tracking fields for precise event recovery using since_id parameter
   * Enables seamless subscription from past point-in-time to real-time pushes
   * EventID can be used with Alpaca SSE since_id parameter for reliable event replay
   */
  EventID?: string | undefined;
  EventTime?:
    | Date
    | undefined;
  /** Broker API specific commission */
  CommissionSettings?: CommissionSettings | undefined;
}

export interface ClientOrderID {
  Network: Network;
  SmartContractAddr: string;
  OrderID: number;
}

export interface BrokerOrderDetailsList {
  BrokerOrderDetailsList: BrokerOrderDetails[];
}

function createBaseBrokerOrderDetails(): BrokerOrderDetails {
  return {
    BrokerAssignedID: "",
    ClientOrderID: undefined,
    SubmittedAt: undefined,
    FilledAt: undefined,
    ExpiredAt: undefined,
    CancelledAt: undefined,
    FailedAt: undefined,
    AssetID: "",
    Symbol: "",
    AssetClass: 0,
    OrderClass: 0,
    Type: 0,
    Side: 0,
    TimeInForce: 0,
    Notional: undefined,
    OrderQty: undefined,
    FilledQty: undefined,
    FilledAvgPrice: undefined,
    LimitPrice: undefined,
    StopPrice: undefined,
    TrailPrice: undefined,
    TrailPercent: undefined,
    HWM: undefined,
    ExtendedHours: false,
    CreatedAt: undefined,
    UpdatedAt: undefined,
    Status: 0,
    TotalPosition: undefined,
    PartialPrice: undefined,
    PartialQty: undefined,
    ProcessInfo: undefined,
    InstanceID: undefined,
    ClearingBroker: 0,
    EventID: undefined,
    EventTime: undefined,
    CommissionSettings: undefined,
  };
}

export const BrokerOrderDetails = {
  encode(message: BrokerOrderDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.BrokerAssignedID !== "") {
      writer.uint32(10).string(message.BrokerAssignedID);
    }
    if (message.ClientOrderID !== undefined) {
      ClientOrderID.encode(message.ClientOrderID, writer.uint32(18).fork()).ldelim();
    }
    if (message.SubmittedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.SubmittedAt), writer.uint32(26).fork()).ldelim();
    }
    if (message.FilledAt !== undefined) {
      Timestamp.encode(toTimestamp(message.FilledAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.ExpiredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.ExpiredAt), writer.uint32(42).fork()).ldelim();
    }
    if (message.CancelledAt !== undefined) {
      Timestamp.encode(toTimestamp(message.CancelledAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.FailedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.FailedAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.AssetID !== "") {
      writer.uint32(66).string(message.AssetID);
    }
    if (message.Symbol !== "") {
      writer.uint32(74).string(message.Symbol);
    }
    if (message.AssetClass !== 0) {
      writer.uint32(80).int32(message.AssetClass);
    }
    if (message.OrderClass !== 0) {
      writer.uint32(88).int32(message.OrderClass);
    }
    if (message.Type !== 0) {
      writer.uint32(96).int32(message.Type);
    }
    if (message.Side !== 0) {
      writer.uint32(104).int32(message.Side);
    }
    if (message.TimeInForce !== 0) {
      writer.uint32(112).int32(message.TimeInForce);
    }
    if (message.Notional !== undefined) {
      Decimal.encode(message.Notional, writer.uint32(122).fork()).ldelim();
    }
    if (message.OrderQty !== undefined) {
      Decimal.encode(message.OrderQty, writer.uint32(130).fork()).ldelim();
    }
    if (message.FilledQty !== undefined) {
      Decimal.encode(message.FilledQty, writer.uint32(138).fork()).ldelim();
    }
    if (message.FilledAvgPrice !== undefined) {
      Decimal.encode(message.FilledAvgPrice, writer.uint32(146).fork()).ldelim();
    }
    if (message.LimitPrice !== undefined) {
      Decimal.encode(message.LimitPrice, writer.uint32(154).fork()).ldelim();
    }
    if (message.StopPrice !== undefined) {
      Decimal.encode(message.StopPrice, writer.uint32(162).fork()).ldelim();
    }
    if (message.TrailPrice !== undefined) {
      Decimal.encode(message.TrailPrice, writer.uint32(170).fork()).ldelim();
    }
    if (message.TrailPercent !== undefined) {
      Decimal.encode(message.TrailPercent, writer.uint32(178).fork()).ldelim();
    }
    if (message.HWM !== undefined) {
      Decimal.encode(message.HWM, writer.uint32(186).fork()).ldelim();
    }
    if (message.ExtendedHours !== false) {
      writer.uint32(192).bool(message.ExtendedHours);
    }
    if (message.CreatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.CreatedAt), writer.uint32(202).fork()).ldelim();
    }
    if (message.UpdatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.UpdatedAt), writer.uint32(210).fork()).ldelim();
    }
    if (message.Status !== 0) {
      writer.uint32(216).int32(message.Status);
    }
    if (message.TotalPosition !== undefined) {
      Decimal.encode(message.TotalPosition, writer.uint32(226).fork()).ldelim();
    }
    if (message.PartialPrice !== undefined) {
      Decimal.encode(message.PartialPrice, writer.uint32(234).fork()).ldelim();
    }
    if (message.PartialQty !== undefined) {
      Decimal.encode(message.PartialQty, writer.uint32(242).fork()).ldelim();
    }
    if (message.ProcessInfo !== undefined) {
      ProcessInfo.encode(message.ProcessInfo, writer.uint32(250).fork()).ldelim();
    }
    if (message.InstanceID !== undefined) {
      writer.uint32(258).string(message.InstanceID);
    }
    if (message.ClearingBroker !== 0) {
      writer.uint32(264).int32(message.ClearingBroker);
    }
    if (message.EventID !== undefined) {
      writer.uint32(290).string(message.EventID);
    }
    if (message.EventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.EventTime), writer.uint32(298).fork()).ldelim();
    }
    if (message.CommissionSettings !== undefined) {
      CommissionSettings.encode(message.CommissionSettings, writer.uint32(306).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BrokerOrderDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerOrderDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.BrokerAssignedID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ClientOrderID = ClientOrderID.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.SubmittedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.FilledAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ExpiredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.CancelledAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.FailedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.AssetID = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.Symbol = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.AssetClass = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.OrderClass = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.Side = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.TimeInForce = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.Notional = Decimal.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.OrderQty = Decimal.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.FilledQty = Decimal.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.FilledAvgPrice = Decimal.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.LimitPrice = Decimal.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.StopPrice = Decimal.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.TrailPrice = Decimal.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.TrailPercent = Decimal.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.HWM = Decimal.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.ExtendedHours = reader.bool();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.CreatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.UpdatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.TotalPosition = Decimal.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.PartialPrice = Decimal.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.PartialQty = Decimal.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.ProcessInfo = ProcessInfo.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.InstanceID = reader.string();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.ClearingBroker = reader.int32() as any;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.EventID = reader.string();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.EventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.CommissionSettings = CommissionSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrokerOrderDetails {
    return {
      BrokerAssignedID: isSet(object.BrokerAssignedID) ? globalThis.String(object.BrokerAssignedID) : "",
      ClientOrderID: isSet(object.ClientOrderID) ? ClientOrderID.fromJSON(object.ClientOrderID) : undefined,
      SubmittedAt: isSet(object.SubmittedAt) ? fromJsonTimestamp(object.SubmittedAt) : undefined,
      FilledAt: isSet(object.FilledAt) ? fromJsonTimestamp(object.FilledAt) : undefined,
      ExpiredAt: isSet(object.ExpiredAt) ? fromJsonTimestamp(object.ExpiredAt) : undefined,
      CancelledAt: isSet(object.CancelledAt) ? fromJsonTimestamp(object.CancelledAt) : undefined,
      FailedAt: isSet(object.FailedAt) ? fromJsonTimestamp(object.FailedAt) : undefined,
      AssetID: isSet(object.AssetID) ? globalThis.String(object.AssetID) : "",
      Symbol: isSet(object.Symbol) ? globalThis.String(object.Symbol) : "",
      AssetClass: isSet(object.AssetClass) ? assetTypeFromJSON(object.AssetClass) : 0,
      OrderClass: isSet(object.OrderClass) ? orderClassFromJSON(object.OrderClass) : 0,
      Type: isSet(object.Type) ? tradeTypeFromJSON(object.Type) : 0,
      Side: isSet(object.Side) ? orderTypeFromJSON(object.Side) : 0,
      TimeInForce: isSet(object.TimeInForce) ? timeInForceFromJSON(object.TimeInForce) : 0,
      Notional: isSet(object.Notional) ? Decimal.fromJSON(object.Notional) : undefined,
      OrderQty: isSet(object.OrderQty) ? Decimal.fromJSON(object.OrderQty) : undefined,
      FilledQty: isSet(object.FilledQty) ? Decimal.fromJSON(object.FilledQty) : undefined,
      FilledAvgPrice: isSet(object.FilledAvgPrice) ? Decimal.fromJSON(object.FilledAvgPrice) : undefined,
      LimitPrice: isSet(object.LimitPrice) ? Decimal.fromJSON(object.LimitPrice) : undefined,
      StopPrice: isSet(object.StopPrice) ? Decimal.fromJSON(object.StopPrice) : undefined,
      TrailPrice: isSet(object.TrailPrice) ? Decimal.fromJSON(object.TrailPrice) : undefined,
      TrailPercent: isSet(object.TrailPercent) ? Decimal.fromJSON(object.TrailPercent) : undefined,
      HWM: isSet(object.HWM) ? Decimal.fromJSON(object.HWM) : undefined,
      ExtendedHours: isSet(object.ExtendedHours) ? globalThis.Boolean(object.ExtendedHours) : false,
      CreatedAt: isSet(object.CreatedAt) ? fromJsonTimestamp(object.CreatedAt) : undefined,
      UpdatedAt: isSet(object.UpdatedAt) ? fromJsonTimestamp(object.UpdatedAt) : undefined,
      Status: isSet(object.Status) ? brokerOrderStatusFromJSON(object.Status) : 0,
      TotalPosition: isSet(object.TotalPosition) ? Decimal.fromJSON(object.TotalPosition) : undefined,
      PartialPrice: isSet(object.PartialPrice) ? Decimal.fromJSON(object.PartialPrice) : undefined,
      PartialQty: isSet(object.PartialQty) ? Decimal.fromJSON(object.PartialQty) : undefined,
      ProcessInfo: isSet(object.ProcessInfo) ? ProcessInfo.fromJSON(object.ProcessInfo) : undefined,
      InstanceID: isSet(object.InstanceID) ? globalThis.String(object.InstanceID) : undefined,
      ClearingBroker: isSet(object.ClearingBroker) ? clearingBrokerFromJSON(object.ClearingBroker) : 0,
      EventID: isSet(object.EventID) ? globalThis.String(object.EventID) : undefined,
      EventTime: isSet(object.EventTime) ? fromJsonTimestamp(object.EventTime) : undefined,
      CommissionSettings: isSet(object.CommissionSettings)
        ? CommissionSettings.fromJSON(object.CommissionSettings)
        : undefined,
    };
  },

  toJSON(message: BrokerOrderDetails): unknown {
    const obj: any = {};
    if (message.BrokerAssignedID !== "") {
      obj.BrokerAssignedID = message.BrokerAssignedID;
    }
    if (message.ClientOrderID !== undefined) {
      obj.ClientOrderID = ClientOrderID.toJSON(message.ClientOrderID);
    }
    if (message.SubmittedAt !== undefined) {
      obj.SubmittedAt = message.SubmittedAt.toISOString();
    }
    if (message.FilledAt !== undefined) {
      obj.FilledAt = message.FilledAt.toISOString();
    }
    if (message.ExpiredAt !== undefined) {
      obj.ExpiredAt = message.ExpiredAt.toISOString();
    }
    if (message.CancelledAt !== undefined) {
      obj.CancelledAt = message.CancelledAt.toISOString();
    }
    if (message.FailedAt !== undefined) {
      obj.FailedAt = message.FailedAt.toISOString();
    }
    if (message.AssetID !== "") {
      obj.AssetID = message.AssetID;
    }
    if (message.Symbol !== "") {
      obj.Symbol = message.Symbol;
    }
    if (message.AssetClass !== 0) {
      obj.AssetClass = assetTypeToJSON(message.AssetClass);
    }
    if (message.OrderClass !== 0) {
      obj.OrderClass = orderClassToJSON(message.OrderClass);
    }
    if (message.Type !== 0) {
      obj.Type = tradeTypeToJSON(message.Type);
    }
    if (message.Side !== 0) {
      obj.Side = orderTypeToJSON(message.Side);
    }
    if (message.TimeInForce !== 0) {
      obj.TimeInForce = timeInForceToJSON(message.TimeInForce);
    }
    if (message.Notional !== undefined) {
      obj.Notional = Decimal.toJSON(message.Notional);
    }
    if (message.OrderQty !== undefined) {
      obj.OrderQty = Decimal.toJSON(message.OrderQty);
    }
    if (message.FilledQty !== undefined) {
      obj.FilledQty = Decimal.toJSON(message.FilledQty);
    }
    if (message.FilledAvgPrice !== undefined) {
      obj.FilledAvgPrice = Decimal.toJSON(message.FilledAvgPrice);
    }
    if (message.LimitPrice !== undefined) {
      obj.LimitPrice = Decimal.toJSON(message.LimitPrice);
    }
    if (message.StopPrice !== undefined) {
      obj.StopPrice = Decimal.toJSON(message.StopPrice);
    }
    if (message.TrailPrice !== undefined) {
      obj.TrailPrice = Decimal.toJSON(message.TrailPrice);
    }
    if (message.TrailPercent !== undefined) {
      obj.TrailPercent = Decimal.toJSON(message.TrailPercent);
    }
    if (message.HWM !== undefined) {
      obj.HWM = Decimal.toJSON(message.HWM);
    }
    if (message.ExtendedHours !== false) {
      obj.ExtendedHours = message.ExtendedHours;
    }
    if (message.CreatedAt !== undefined) {
      obj.CreatedAt = message.CreatedAt.toISOString();
    }
    if (message.UpdatedAt !== undefined) {
      obj.UpdatedAt = message.UpdatedAt.toISOString();
    }
    if (message.Status !== 0) {
      obj.Status = brokerOrderStatusToJSON(message.Status);
    }
    if (message.TotalPosition !== undefined) {
      obj.TotalPosition = Decimal.toJSON(message.TotalPosition);
    }
    if (message.PartialPrice !== undefined) {
      obj.PartialPrice = Decimal.toJSON(message.PartialPrice);
    }
    if (message.PartialQty !== undefined) {
      obj.PartialQty = Decimal.toJSON(message.PartialQty);
    }
    if (message.ProcessInfo !== undefined) {
      obj.ProcessInfo = ProcessInfo.toJSON(message.ProcessInfo);
    }
    if (message.InstanceID !== undefined) {
      obj.InstanceID = message.InstanceID;
    }
    if (message.ClearingBroker !== 0) {
      obj.ClearingBroker = clearingBrokerToJSON(message.ClearingBroker);
    }
    if (message.EventID !== undefined) {
      obj.EventID = message.EventID;
    }
    if (message.EventTime !== undefined) {
      obj.EventTime = message.EventTime.toISOString();
    }
    if (message.CommissionSettings !== undefined) {
      obj.CommissionSettings = CommissionSettings.toJSON(message.CommissionSettings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BrokerOrderDetails>, I>>(base?: I): BrokerOrderDetails {
    return BrokerOrderDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BrokerOrderDetails>, I>>(object: I): BrokerOrderDetails {
    const message = createBaseBrokerOrderDetails();
    message.BrokerAssignedID = object.BrokerAssignedID ?? "";
    message.ClientOrderID = (object.ClientOrderID !== undefined && object.ClientOrderID !== null)
      ? ClientOrderID.fromPartial(object.ClientOrderID)
      : undefined;
    message.SubmittedAt = object.SubmittedAt ?? undefined;
    message.FilledAt = object.FilledAt ?? undefined;
    message.ExpiredAt = object.ExpiredAt ?? undefined;
    message.CancelledAt = object.CancelledAt ?? undefined;
    message.FailedAt = object.FailedAt ?? undefined;
    message.AssetID = object.AssetID ?? "";
    message.Symbol = object.Symbol ?? "";
    message.AssetClass = object.AssetClass ?? 0;
    message.OrderClass = object.OrderClass ?? 0;
    message.Type = object.Type ?? 0;
    message.Side = object.Side ?? 0;
    message.TimeInForce = object.TimeInForce ?? 0;
    message.Notional = (object.Notional !== undefined && object.Notional !== null)
      ? Decimal.fromPartial(object.Notional)
      : undefined;
    message.OrderQty = (object.OrderQty !== undefined && object.OrderQty !== null)
      ? Decimal.fromPartial(object.OrderQty)
      : undefined;
    message.FilledQty = (object.FilledQty !== undefined && object.FilledQty !== null)
      ? Decimal.fromPartial(object.FilledQty)
      : undefined;
    message.FilledAvgPrice = (object.FilledAvgPrice !== undefined && object.FilledAvgPrice !== null)
      ? Decimal.fromPartial(object.FilledAvgPrice)
      : undefined;
    message.LimitPrice = (object.LimitPrice !== undefined && object.LimitPrice !== null)
      ? Decimal.fromPartial(object.LimitPrice)
      : undefined;
    message.StopPrice = (object.StopPrice !== undefined && object.StopPrice !== null)
      ? Decimal.fromPartial(object.StopPrice)
      : undefined;
    message.TrailPrice = (object.TrailPrice !== undefined && object.TrailPrice !== null)
      ? Decimal.fromPartial(object.TrailPrice)
      : undefined;
    message.TrailPercent = (object.TrailPercent !== undefined && object.TrailPercent !== null)
      ? Decimal.fromPartial(object.TrailPercent)
      : undefined;
    message.HWM = (object.HWM !== undefined && object.HWM !== null) ? Decimal.fromPartial(object.HWM) : undefined;
    message.ExtendedHours = object.ExtendedHours ?? false;
    message.CreatedAt = object.CreatedAt ?? undefined;
    message.UpdatedAt = object.UpdatedAt ?? undefined;
    message.Status = object.Status ?? 0;
    message.TotalPosition = (object.TotalPosition !== undefined && object.TotalPosition !== null)
      ? Decimal.fromPartial(object.TotalPosition)
      : undefined;
    message.PartialPrice = (object.PartialPrice !== undefined && object.PartialPrice !== null)
      ? Decimal.fromPartial(object.PartialPrice)
      : undefined;
    message.PartialQty = (object.PartialQty !== undefined && object.PartialQty !== null)
      ? Decimal.fromPartial(object.PartialQty)
      : undefined;
    message.ProcessInfo = (object.ProcessInfo !== undefined && object.ProcessInfo !== null)
      ? ProcessInfo.fromPartial(object.ProcessInfo)
      : undefined;
    message.InstanceID = object.InstanceID ?? undefined;
    message.ClearingBroker = object.ClearingBroker ?? 0;
    message.EventID = object.EventID ?? undefined;
    message.EventTime = object.EventTime ?? undefined;
    message.CommissionSettings = (object.CommissionSettings !== undefined && object.CommissionSettings !== null)
      ? CommissionSettings.fromPartial(object.CommissionSettings)
      : undefined;
    return message;
  },
};

function createBaseClientOrderID(): ClientOrderID {
  return { Network: 0, SmartContractAddr: "", OrderID: 0 };
}

export const ClientOrderID = {
  encode(message: ClientOrderID, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Network !== 0) {
      writer.uint32(8).int32(message.Network);
    }
    if (message.SmartContractAddr !== "") {
      writer.uint32(18).string(message.SmartContractAddr);
    }
    if (message.OrderID !== 0) {
      writer.uint32(24).int64(message.OrderID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientOrderID {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientOrderID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.Network = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.SmartContractAddr = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.OrderID = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientOrderID {
    return {
      Network: isSet(object.Network) ? networkFromJSON(object.Network) : 0,
      SmartContractAddr: isSet(object.SmartContractAddr) ? globalThis.String(object.SmartContractAddr) : "",
      OrderID: isSet(object.OrderID) ? globalThis.Number(object.OrderID) : 0,
    };
  },

  toJSON(message: ClientOrderID): unknown {
    const obj: any = {};
    if (message.Network !== 0) {
      obj.Network = networkToJSON(message.Network);
    }
    if (message.SmartContractAddr !== "") {
      obj.SmartContractAddr = message.SmartContractAddr;
    }
    if (message.OrderID !== 0) {
      obj.OrderID = Math.round(message.OrderID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientOrderID>, I>>(base?: I): ClientOrderID {
    return ClientOrderID.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientOrderID>, I>>(object: I): ClientOrderID {
    const message = createBaseClientOrderID();
    message.Network = object.Network ?? 0;
    message.SmartContractAddr = object.SmartContractAddr ?? "";
    message.OrderID = object.OrderID ?? 0;
    return message;
  },
};

function createBaseBrokerOrderDetailsList(): BrokerOrderDetailsList {
  return { BrokerOrderDetailsList: [] };
}

export const BrokerOrderDetailsList = {
  encode(message: BrokerOrderDetailsList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.BrokerOrderDetailsList) {
      BrokerOrderDetails.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BrokerOrderDetailsList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerOrderDetailsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.BrokerOrderDetailsList.push(BrokerOrderDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrokerOrderDetailsList {
    return {
      BrokerOrderDetailsList: globalThis.Array.isArray(object?.BrokerOrderDetailsList)
        ? object.BrokerOrderDetailsList.map((e: any) => BrokerOrderDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BrokerOrderDetailsList): unknown {
    const obj: any = {};
    if (message.BrokerOrderDetailsList?.length) {
      obj.BrokerOrderDetailsList = message.BrokerOrderDetailsList.map((e) => BrokerOrderDetails.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BrokerOrderDetailsList>, I>>(base?: I): BrokerOrderDetailsList {
    return BrokerOrderDetailsList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BrokerOrderDetailsList>, I>>(object: I): BrokerOrderDetailsList {
    const message = createBaseBrokerOrderDetailsList();
    message.BrokerOrderDetailsList = object.BrokerOrderDetailsList?.map((e) => BrokerOrderDetails.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
