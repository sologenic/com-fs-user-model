// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: sologenic/com-fs-trade-profile-model/tradeprofile.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Audit } from "../com-fs-utils-lib/models/audit/audit";
import { MetaData } from "../com-fs-utils-lib/models/metadata/metadata";

export const protobufPackage = "tradeprofile";

/** MAINTENANCE: THIS SHOULD BE UPDATED WHENEVER A NEW FIELD IS ADDED TO THE TRADE PROFILE */
export enum LockableField {
  LOCKABLE_FIELD_DO_NOT_USE = 0,
  IS_TRADING_ENABLED = 1,
  IS_ORDER_ACCEPTANCE_ENABLED = 2,
  IS_MARGIN_TRADING_ENABLED = 3,
  UNRECOGNIZED = -1,
}

export function lockableFieldFromJSON(object: any): LockableField {
  switch (object) {
    case 0:
    case "LOCKABLE_FIELD_DO_NOT_USE":
      return LockableField.LOCKABLE_FIELD_DO_NOT_USE;
    case 1:
    case "IS_TRADING_ENABLED":
      return LockableField.IS_TRADING_ENABLED;
    case 2:
    case "IS_ORDER_ACCEPTANCE_ENABLED":
      return LockableField.IS_ORDER_ACCEPTANCE_ENABLED;
    case 3:
    case "IS_MARGIN_TRADING_ENABLED":
      return LockableField.IS_MARGIN_TRADING_ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LockableField.UNRECOGNIZED;
  }
}

export function lockableFieldToJSON(object: LockableField): string {
  switch (object) {
    case LockableField.LOCKABLE_FIELD_DO_NOT_USE:
      return "LOCKABLE_FIELD_DO_NOT_USE";
    case LockableField.IS_TRADING_ENABLED:
      return "IS_TRADING_ENABLED";
    case LockableField.IS_ORDER_ACCEPTANCE_ENABLED:
      return "IS_ORDER_ACCEPTANCE_ENABLED";
    case LockableField.IS_MARGIN_TRADING_ENABLED:
      return "IS_MARGIN_TRADING_ENABLED";
    case LockableField.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Key: OrganizationID-Network */
export interface DefaultTradeProfile {
  DefaultValues: TradeProfileDetails | undefined;
  ControlMetadata: TradeProfileControlMetadata | undefined;
  OrganizationID?: string | undefined;
  MetaData: MetaData | undefined;
  Audit: Audit | undefined;
}

/**
 * Trade profile details that are used in two ways:
 * 1. Default trade profile for an organization(DefaultValues)
 * 2. Embedded in a user's model for individual trade profile configuration
 */
export interface TradeProfileDetails {
  /** Boolean fields */
  IsTradingEnabled: boolean;
  /** If true, orders are accepted; if false, close and cancel Only */
  IsOrderAcceptanceEnabled: boolean;
  /** If true, enables margin trading (buying power); if false, trading is limited to cash position. */
  IsMarginTradingEnabled: boolean;
  /** If true, enables short selling */
  IsShortSellingEnabled: boolean;
  /** Dropdown selection fields */
  AggregateNotionalLimit:
    | DropdownNumericValue
    | undefined;
  /** Maximum single order value - limits the total monetary value allowed per order */
  SingleOrderLimit:
    | DropdownNumericValue
    | undefined;
  /** Maximum order quantity - limits the number of shares per order */
  MaxOrderQuantity:
    | DropdownNumericValue
    | undefined;
  /** Numeric fields */
  AggressivePercentage: number;
  /** Maximum allowed share quantity as a percentage of the security's average daily volume. */
  SymbolGrossADVPercent: number;
  /** The maximum allowed deviation percentage from market price */
  PriceCheckDeviation: number;
  /** Duplicative order threshold - rejects repetitive orders of same type in same symbol */
  DuplicateOrderLimit: number;
  /** Risk based multiplier */
  RiskMultiplier: number;
<<<<<<< HEAD
=======
}

/** This is user mutable. User can change this limited only by the admin set configuration. */
export interface UserTradeProfile {
  /** If true, enables margin trading (buying power); if false, trading is limited to cash position. */
  IsMarginTradingEnabled: boolean;
  /** If true, enables short selling */
  IsShortSellingEnabled: boolean;
  /** Maximum single order value - limits the total monetary value allowed per order */
  SingleOrderLimit: number;
  /** Maximum order quantity - limits the number of shares per order */
  MaxOrderQuantity: number;
>>>>>>> db9c8c5 (added user trade profile property for the user)
}

export interface TradeProfileControlMetadata {
  LockedFields: LockableField[];
  /** Available options for dropdowns fields */
  AggregateNotionalLimitOptions: DropdownNumericValue[];
  SingleOrderLimitOptions: DropdownNumericValue[];
  MaxOrderQuantityOptions: DropdownNumericValue[];
  /** Min/Max constraints for numeric fields */
  AggressivePercentageConstraint: DecimalConstraint | undefined;
  SymbolGrossADVConstraint: DecimalConstraint | undefined;
  PriceCheckDeviationConstraint: DecimalConstraint | undefined;
  DuplicateOrderConstraint: IntConstraint | undefined;
  RiskMultiplierConstraint: DecimalConstraint | undefined;
}

export interface DropdownNumericValue {
  /** Numeric value (e.g. 1000) */
  Value: number;
  /** if true, the value must be greater than the Value value (e.g. > 1000) */
  IsGreaterThan?: boolean | undefined;
}

export interface DecimalConstraint {
  MinValue: number;
  MaxValue: number;
  /** Increment/decrement step size, e.g., 0.01(1%), 0.001(0.1%) */
  Step: number;
}

export interface IntConstraint {
  MinValue: number;
  MaxValue: number;
  /** Increment/decrement step size, e.g., 1, 5, 10 */
  Step: number;
}

function createBaseDefaultTradeProfile(): DefaultTradeProfile {
  return {
    DefaultValues: undefined,
    ControlMetadata: undefined,
    OrganizationID: undefined,
    MetaData: undefined,
    Audit: undefined,
  };
}

export const DefaultTradeProfile = {
  encode(message: DefaultTradeProfile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.DefaultValues !== undefined) {
      TradeProfileDetails.encode(message.DefaultValues, writer.uint32(10).fork()).ldelim();
    }
    if (message.ControlMetadata !== undefined) {
      TradeProfileControlMetadata.encode(message.ControlMetadata, writer.uint32(18).fork()).ldelim();
    }
    if (message.OrganizationID !== undefined) {
      writer.uint32(26).string(message.OrganizationID);
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(34).fork()).ldelim();
    }
    if (message.Audit !== undefined) {
      Audit.encode(message.Audit, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DefaultTradeProfile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultTradeProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.DefaultValues = TradeProfileDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ControlMetadata = TradeProfileControlMetadata.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Audit = Audit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultTradeProfile {
    return {
      DefaultValues: isSet(object.DefaultValues) ? TradeProfileDetails.fromJSON(object.DefaultValues) : undefined,
      ControlMetadata: isSet(object.ControlMetadata)
        ? TradeProfileControlMetadata.fromJSON(object.ControlMetadata)
        : undefined,
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : undefined,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      Audit: isSet(object.Audit) ? Audit.fromJSON(object.Audit) : undefined,
    };
  },

  toJSON(message: DefaultTradeProfile): unknown {
    const obj: any = {};
    if (message.DefaultValues !== undefined) {
      obj.DefaultValues = TradeProfileDetails.toJSON(message.DefaultValues);
    }
    if (message.ControlMetadata !== undefined) {
      obj.ControlMetadata = TradeProfileControlMetadata.toJSON(message.ControlMetadata);
    }
    if (message.OrganizationID !== undefined) {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.Audit !== undefined) {
      obj.Audit = Audit.toJSON(message.Audit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultTradeProfile>, I>>(base?: I): DefaultTradeProfile {
    return DefaultTradeProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultTradeProfile>, I>>(object: I): DefaultTradeProfile {
    const message = createBaseDefaultTradeProfile();
    message.DefaultValues = (object.DefaultValues !== undefined && object.DefaultValues !== null)
      ? TradeProfileDetails.fromPartial(object.DefaultValues)
      : undefined;
    message.ControlMetadata = (object.ControlMetadata !== undefined && object.ControlMetadata !== null)
      ? TradeProfileControlMetadata.fromPartial(object.ControlMetadata)
      : undefined;
    message.OrganizationID = object.OrganizationID ?? undefined;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.Audit = (object.Audit !== undefined && object.Audit !== null) ? Audit.fromPartial(object.Audit) : undefined;
    return message;
  },
};

function createBaseTradeProfileDetails(): TradeProfileDetails {
  return {
    IsTradingEnabled: false,
    IsOrderAcceptanceEnabled: false,
    IsMarginTradingEnabled: false,
    IsShortSellingEnabled: false,
    AggregateNotionalLimit: undefined,
    SingleOrderLimit: undefined,
    MaxOrderQuantity: undefined,
    AggressivePercentage: 0,
    SymbolGrossADVPercent: 0,
    PriceCheckDeviation: 0,
    DuplicateOrderLimit: 0,
    RiskMultiplier: 0,
  };
}

export const TradeProfileDetails = {
  encode(message: TradeProfileDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.IsTradingEnabled !== false) {
      writer.uint32(8).bool(message.IsTradingEnabled);
    }
    if (message.IsOrderAcceptanceEnabled !== false) {
      writer.uint32(16).bool(message.IsOrderAcceptanceEnabled);
    }
    if (message.IsMarginTradingEnabled !== false) {
      writer.uint32(24).bool(message.IsMarginTradingEnabled);
    }
    if (message.IsShortSellingEnabled !== false) {
      writer.uint32(32).bool(message.IsShortSellingEnabled);
    }
    if (message.AggregateNotionalLimit !== undefined) {
      DropdownNumericValue.encode(message.AggregateNotionalLimit, writer.uint32(802).fork()).ldelim();
    }
    if (message.SingleOrderLimit !== undefined) {
      DropdownNumericValue.encode(message.SingleOrderLimit, writer.uint32(810).fork()).ldelim();
    }
    if (message.MaxOrderQuantity !== undefined) {
      DropdownNumericValue.encode(message.MaxOrderQuantity, writer.uint32(818).fork()).ldelim();
    }
    if (message.AggressivePercentage !== 0) {
      writer.uint32(1609).double(message.AggressivePercentage);
    }
    if (message.SymbolGrossADVPercent !== 0) {
      writer.uint32(1617).double(message.SymbolGrossADVPercent);
    }
    if (message.PriceCheckDeviation !== 0) {
      writer.uint32(1625).double(message.PriceCheckDeviation);
    }
    if (message.DuplicateOrderLimit !== 0) {
      writer.uint32(1632).int32(message.DuplicateOrderLimit);
    }
    if (message.RiskMultiplier !== 0) {
      writer.uint32(1641).double(message.RiskMultiplier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradeProfileDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeProfileDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.IsTradingEnabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.IsOrderAcceptanceEnabled = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.IsMarginTradingEnabled = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.IsShortSellingEnabled = reader.bool();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.AggregateNotionalLimit = DropdownNumericValue.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.SingleOrderLimit = DropdownNumericValue.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.MaxOrderQuantity = DropdownNumericValue.decode(reader, reader.uint32());
          continue;
        case 201:
          if (tag !== 1609) {
            break;
          }

          message.AggressivePercentage = reader.double();
          continue;
        case 202:
          if (tag !== 1617) {
            break;
          }

          message.SymbolGrossADVPercent = reader.double();
          continue;
        case 203:
          if (tag !== 1625) {
            break;
          }

          message.PriceCheckDeviation = reader.double();
          continue;
        case 204:
          if (tag !== 1632) {
            break;
          }

          message.DuplicateOrderLimit = reader.int32();
          continue;
        case 205:
          if (tag !== 1641) {
            break;
          }

          message.RiskMultiplier = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TradeProfileDetails {
    return {
      IsTradingEnabled: isSet(object.IsTradingEnabled) ? globalThis.Boolean(object.IsTradingEnabled) : false,
      IsOrderAcceptanceEnabled: isSet(object.IsOrderAcceptanceEnabled)
        ? globalThis.Boolean(object.IsOrderAcceptanceEnabled)
        : false,
      IsMarginTradingEnabled: isSet(object.IsMarginTradingEnabled)
        ? globalThis.Boolean(object.IsMarginTradingEnabled)
        : false,
      IsShortSellingEnabled: isSet(object.IsShortSellingEnabled)
        ? globalThis.Boolean(object.IsShortSellingEnabled)
        : false,
      AggregateNotionalLimit: isSet(object.AggregateNotionalLimit)
        ? DropdownNumericValue.fromJSON(object.AggregateNotionalLimit)
        : undefined,
      SingleOrderLimit: isSet(object.SingleOrderLimit)
        ? DropdownNumericValue.fromJSON(object.SingleOrderLimit)
        : undefined,
      MaxOrderQuantity: isSet(object.MaxOrderQuantity)
        ? DropdownNumericValue.fromJSON(object.MaxOrderQuantity)
        : undefined,
      AggressivePercentage: isSet(object.AggressivePercentage) ? globalThis.Number(object.AggressivePercentage) : 0,
      SymbolGrossADVPercent: isSet(object.SymbolGrossADVPercent) ? globalThis.Number(object.SymbolGrossADVPercent) : 0,
      PriceCheckDeviation: isSet(object.PriceCheckDeviation) ? globalThis.Number(object.PriceCheckDeviation) : 0,
      DuplicateOrderLimit: isSet(object.DuplicateOrderLimit) ? globalThis.Number(object.DuplicateOrderLimit) : 0,
      RiskMultiplier: isSet(object.RiskMultiplier) ? globalThis.Number(object.RiskMultiplier) : 0,
    };
  },

  toJSON(message: TradeProfileDetails): unknown {
    const obj: any = {};
    if (message.IsTradingEnabled !== false) {
      obj.IsTradingEnabled = message.IsTradingEnabled;
    }
    if (message.IsOrderAcceptanceEnabled !== false) {
      obj.IsOrderAcceptanceEnabled = message.IsOrderAcceptanceEnabled;
    }
    if (message.IsMarginTradingEnabled !== false) {
      obj.IsMarginTradingEnabled = message.IsMarginTradingEnabled;
    }
    if (message.IsShortSellingEnabled !== false) {
      obj.IsShortSellingEnabled = message.IsShortSellingEnabled;
    }
    if (message.AggregateNotionalLimit !== undefined) {
      obj.AggregateNotionalLimit = DropdownNumericValue.toJSON(message.AggregateNotionalLimit);
    }
    if (message.SingleOrderLimit !== undefined) {
      obj.SingleOrderLimit = DropdownNumericValue.toJSON(message.SingleOrderLimit);
    }
    if (message.MaxOrderQuantity !== undefined) {
      obj.MaxOrderQuantity = DropdownNumericValue.toJSON(message.MaxOrderQuantity);
    }
    if (message.AggressivePercentage !== 0) {
      obj.AggressivePercentage = message.AggressivePercentage;
    }
    if (message.SymbolGrossADVPercent !== 0) {
      obj.SymbolGrossADVPercent = message.SymbolGrossADVPercent;
    }
    if (message.PriceCheckDeviation !== 0) {
      obj.PriceCheckDeviation = message.PriceCheckDeviation;
    }
    if (message.DuplicateOrderLimit !== 0) {
      obj.DuplicateOrderLimit = Math.round(message.DuplicateOrderLimit);
    }
    if (message.RiskMultiplier !== 0) {
      obj.RiskMultiplier = message.RiskMultiplier;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeProfileDetails>, I>>(base?: I): TradeProfileDetails {
    return TradeProfileDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeProfileDetails>, I>>(object: I): TradeProfileDetails {
    const message = createBaseTradeProfileDetails();
    message.IsTradingEnabled = object.IsTradingEnabled ?? false;
    message.IsOrderAcceptanceEnabled = object.IsOrderAcceptanceEnabled ?? false;
    message.IsMarginTradingEnabled = object.IsMarginTradingEnabled ?? false;
    message.IsShortSellingEnabled = object.IsShortSellingEnabled ?? false;
    message.AggregateNotionalLimit =
      (object.AggregateNotionalLimit !== undefined && object.AggregateNotionalLimit !== null)
        ? DropdownNumericValue.fromPartial(object.AggregateNotionalLimit)
        : undefined;
    message.SingleOrderLimit = (object.SingleOrderLimit !== undefined && object.SingleOrderLimit !== null)
      ? DropdownNumericValue.fromPartial(object.SingleOrderLimit)
      : undefined;
    message.MaxOrderQuantity = (object.MaxOrderQuantity !== undefined && object.MaxOrderQuantity !== null)
      ? DropdownNumericValue.fromPartial(object.MaxOrderQuantity)
      : undefined;
    message.AggressivePercentage = object.AggressivePercentage ?? 0;
    message.SymbolGrossADVPercent = object.SymbolGrossADVPercent ?? 0;
    message.PriceCheckDeviation = object.PriceCheckDeviation ?? 0;
    message.DuplicateOrderLimit = object.DuplicateOrderLimit ?? 0;
    message.RiskMultiplier = object.RiskMultiplier ?? 0;
<<<<<<< HEAD
=======
    return message;
  },
};

function createBaseUserTradeProfile(): UserTradeProfile {
  return { IsMarginTradingEnabled: false, IsShortSellingEnabled: false, SingleOrderLimit: 0, MaxOrderQuantity: 0 };
}

export const UserTradeProfile = {
  encode(message: UserTradeProfile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.IsMarginTradingEnabled !== false) {
      writer.uint32(8).bool(message.IsMarginTradingEnabled);
    }
    if (message.IsShortSellingEnabled !== false) {
      writer.uint32(16).bool(message.IsShortSellingEnabled);
    }
    if (message.SingleOrderLimit !== 0) {
      writer.uint32(24).int32(message.SingleOrderLimit);
    }
    if (message.MaxOrderQuantity !== 0) {
      writer.uint32(32).int32(message.MaxOrderQuantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTradeProfile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTradeProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.IsMarginTradingEnabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.IsShortSellingEnabled = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.SingleOrderLimit = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.MaxOrderQuantity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTradeProfile {
    return {
      IsMarginTradingEnabled: isSet(object.IsMarginTradingEnabled)
        ? globalThis.Boolean(object.IsMarginTradingEnabled)
        : false,
      IsShortSellingEnabled: isSet(object.IsShortSellingEnabled)
        ? globalThis.Boolean(object.IsShortSellingEnabled)
        : false,
      SingleOrderLimit: isSet(object.SingleOrderLimit) ? globalThis.Number(object.SingleOrderLimit) : 0,
      MaxOrderQuantity: isSet(object.MaxOrderQuantity) ? globalThis.Number(object.MaxOrderQuantity) : 0,
    };
  },

  toJSON(message: UserTradeProfile): unknown {
    const obj: any = {};
    if (message.IsMarginTradingEnabled !== false) {
      obj.IsMarginTradingEnabled = message.IsMarginTradingEnabled;
    }
    if (message.IsShortSellingEnabled !== false) {
      obj.IsShortSellingEnabled = message.IsShortSellingEnabled;
    }
    if (message.SingleOrderLimit !== 0) {
      obj.SingleOrderLimit = Math.round(message.SingleOrderLimit);
    }
    if (message.MaxOrderQuantity !== 0) {
      obj.MaxOrderQuantity = Math.round(message.MaxOrderQuantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserTradeProfile>, I>>(base?: I): UserTradeProfile {
    return UserTradeProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserTradeProfile>, I>>(object: I): UserTradeProfile {
    const message = createBaseUserTradeProfile();
    message.IsMarginTradingEnabled = object.IsMarginTradingEnabled ?? false;
    message.IsShortSellingEnabled = object.IsShortSellingEnabled ?? false;
    message.SingleOrderLimit = object.SingleOrderLimit ?? 0;
    message.MaxOrderQuantity = object.MaxOrderQuantity ?? 0;
>>>>>>> db9c8c5 (added user trade profile property for the user)
    return message;
  },
};

function createBaseTradeProfileControlMetadata(): TradeProfileControlMetadata {
  return {
    LockedFields: [],
    AggregateNotionalLimitOptions: [],
    SingleOrderLimitOptions: [],
    MaxOrderQuantityOptions: [],
    AggressivePercentageConstraint: undefined,
    SymbolGrossADVConstraint: undefined,
    PriceCheckDeviationConstraint: undefined,
    DuplicateOrderConstraint: undefined,
    RiskMultiplierConstraint: undefined,
  };
}

export const TradeProfileControlMetadata = {
  encode(message: TradeProfileControlMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.LockedFields) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.AggregateNotionalLimitOptions) {
      DropdownNumericValue.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.SingleOrderLimitOptions) {
      DropdownNumericValue.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.MaxOrderQuantityOptions) {
      DropdownNumericValue.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.AggressivePercentageConstraint !== undefined) {
      DecimalConstraint.encode(message.AggressivePercentageConstraint, writer.uint32(810).fork()).ldelim();
    }
    if (message.SymbolGrossADVConstraint !== undefined) {
      DecimalConstraint.encode(message.SymbolGrossADVConstraint, writer.uint32(818).fork()).ldelim();
    }
    if (message.PriceCheckDeviationConstraint !== undefined) {
      DecimalConstraint.encode(message.PriceCheckDeviationConstraint, writer.uint32(826).fork()).ldelim();
    }
    if (message.DuplicateOrderConstraint !== undefined) {
      IntConstraint.encode(message.DuplicateOrderConstraint, writer.uint32(834).fork()).ldelim();
    }
    if (message.RiskMultiplierConstraint !== undefined) {
      DecimalConstraint.encode(message.RiskMultiplierConstraint, writer.uint32(842).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradeProfileControlMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeProfileControlMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.LockedFields.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.LockedFields.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.AggregateNotionalLimitOptions.push(DropdownNumericValue.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.SingleOrderLimitOptions.push(DropdownNumericValue.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.MaxOrderQuantityOptions.push(DropdownNumericValue.decode(reader, reader.uint32()));
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.AggressivePercentageConstraint = DecimalConstraint.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.SymbolGrossADVConstraint = DecimalConstraint.decode(reader, reader.uint32());
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.PriceCheckDeviationConstraint = DecimalConstraint.decode(reader, reader.uint32());
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }

          message.DuplicateOrderConstraint = IntConstraint.decode(reader, reader.uint32());
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }

          message.RiskMultiplierConstraint = DecimalConstraint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TradeProfileControlMetadata {
    return {
      LockedFields: globalThis.Array.isArray(object?.LockedFields)
        ? object.LockedFields.map((e: any) => lockableFieldFromJSON(e))
        : [],
      AggregateNotionalLimitOptions: globalThis.Array.isArray(object?.AggregateNotionalLimitOptions)
        ? object.AggregateNotionalLimitOptions.map((e: any) => DropdownNumericValue.fromJSON(e))
        : [],
      SingleOrderLimitOptions: globalThis.Array.isArray(object?.SingleOrderLimitOptions)
        ? object.SingleOrderLimitOptions.map((e: any) => DropdownNumericValue.fromJSON(e))
        : [],
      MaxOrderQuantityOptions: globalThis.Array.isArray(object?.MaxOrderQuantityOptions)
        ? object.MaxOrderQuantityOptions.map((e: any) => DropdownNumericValue.fromJSON(e))
        : [],
      AggressivePercentageConstraint: isSet(object.AggressivePercentageConstraint)
        ? DecimalConstraint.fromJSON(object.AggressivePercentageConstraint)
        : undefined,
      SymbolGrossADVConstraint: isSet(object.SymbolGrossADVConstraint)
        ? DecimalConstraint.fromJSON(object.SymbolGrossADVConstraint)
        : undefined,
      PriceCheckDeviationConstraint: isSet(object.PriceCheckDeviationConstraint)
        ? DecimalConstraint.fromJSON(object.PriceCheckDeviationConstraint)
        : undefined,
      DuplicateOrderConstraint: isSet(object.DuplicateOrderConstraint)
        ? IntConstraint.fromJSON(object.DuplicateOrderConstraint)
        : undefined,
      RiskMultiplierConstraint: isSet(object.RiskMultiplierConstraint)
        ? DecimalConstraint.fromJSON(object.RiskMultiplierConstraint)
        : undefined,
    };
  },

  toJSON(message: TradeProfileControlMetadata): unknown {
    const obj: any = {};
    if (message.LockedFields?.length) {
      obj.LockedFields = message.LockedFields.map((e) => lockableFieldToJSON(e));
    }
    if (message.AggregateNotionalLimitOptions?.length) {
      obj.AggregateNotionalLimitOptions = message.AggregateNotionalLimitOptions.map((e) =>
        DropdownNumericValue.toJSON(e)
      );
    }
    if (message.SingleOrderLimitOptions?.length) {
      obj.SingleOrderLimitOptions = message.SingleOrderLimitOptions.map((e) => DropdownNumericValue.toJSON(e));
    }
    if (message.MaxOrderQuantityOptions?.length) {
      obj.MaxOrderQuantityOptions = message.MaxOrderQuantityOptions.map((e) => DropdownNumericValue.toJSON(e));
    }
    if (message.AggressivePercentageConstraint !== undefined) {
      obj.AggressivePercentageConstraint = DecimalConstraint.toJSON(message.AggressivePercentageConstraint);
    }
    if (message.SymbolGrossADVConstraint !== undefined) {
      obj.SymbolGrossADVConstraint = DecimalConstraint.toJSON(message.SymbolGrossADVConstraint);
    }
    if (message.PriceCheckDeviationConstraint !== undefined) {
      obj.PriceCheckDeviationConstraint = DecimalConstraint.toJSON(message.PriceCheckDeviationConstraint);
    }
    if (message.DuplicateOrderConstraint !== undefined) {
      obj.DuplicateOrderConstraint = IntConstraint.toJSON(message.DuplicateOrderConstraint);
    }
    if (message.RiskMultiplierConstraint !== undefined) {
      obj.RiskMultiplierConstraint = DecimalConstraint.toJSON(message.RiskMultiplierConstraint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeProfileControlMetadata>, I>>(base?: I): TradeProfileControlMetadata {
    return TradeProfileControlMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeProfileControlMetadata>, I>>(object: I): TradeProfileControlMetadata {
    const message = createBaseTradeProfileControlMetadata();
    message.LockedFields = object.LockedFields?.map((e) => e) || [];
    message.AggregateNotionalLimitOptions =
      object.AggregateNotionalLimitOptions?.map((e) => DropdownNumericValue.fromPartial(e)) || [];
    message.SingleOrderLimitOptions = object.SingleOrderLimitOptions?.map((e) => DropdownNumericValue.fromPartial(e)) ||
      [];
    message.MaxOrderQuantityOptions = object.MaxOrderQuantityOptions?.map((e) => DropdownNumericValue.fromPartial(e)) ||
      [];
    message.AggressivePercentageConstraint =
      (object.AggressivePercentageConstraint !== undefined && object.AggressivePercentageConstraint !== null)
        ? DecimalConstraint.fromPartial(object.AggressivePercentageConstraint)
        : undefined;
    message.SymbolGrossADVConstraint =
      (object.SymbolGrossADVConstraint !== undefined && object.SymbolGrossADVConstraint !== null)
        ? DecimalConstraint.fromPartial(object.SymbolGrossADVConstraint)
        : undefined;
    message.PriceCheckDeviationConstraint =
      (object.PriceCheckDeviationConstraint !== undefined && object.PriceCheckDeviationConstraint !== null)
        ? DecimalConstraint.fromPartial(object.PriceCheckDeviationConstraint)
        : undefined;
    message.DuplicateOrderConstraint =
      (object.DuplicateOrderConstraint !== undefined && object.DuplicateOrderConstraint !== null)
        ? IntConstraint.fromPartial(object.DuplicateOrderConstraint)
        : undefined;
    message.RiskMultiplierConstraint =
      (object.RiskMultiplierConstraint !== undefined && object.RiskMultiplierConstraint !== null)
        ? DecimalConstraint.fromPartial(object.RiskMultiplierConstraint)
        : undefined;
    return message;
  },
};

function createBaseDropdownNumericValue(): DropdownNumericValue {
  return { Value: 0, IsGreaterThan: undefined };
}

export const DropdownNumericValue = {
  encode(message: DropdownNumericValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Value !== 0) {
      writer.uint32(8).int32(message.Value);
    }
    if (message.IsGreaterThan !== undefined) {
      writer.uint32(16).bool(message.IsGreaterThan);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DropdownNumericValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropdownNumericValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.Value = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.IsGreaterThan = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropdownNumericValue {
    return {
      Value: isSet(object.Value) ? globalThis.Number(object.Value) : 0,
      IsGreaterThan: isSet(object.IsGreaterThan) ? globalThis.Boolean(object.IsGreaterThan) : undefined,
    };
  },

  toJSON(message: DropdownNumericValue): unknown {
    const obj: any = {};
    if (message.Value !== 0) {
      obj.Value = Math.round(message.Value);
    }
    if (message.IsGreaterThan !== undefined) {
      obj.IsGreaterThan = message.IsGreaterThan;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DropdownNumericValue>, I>>(base?: I): DropdownNumericValue {
    return DropdownNumericValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DropdownNumericValue>, I>>(object: I): DropdownNumericValue {
    const message = createBaseDropdownNumericValue();
    message.Value = object.Value ?? 0;
    message.IsGreaterThan = object.IsGreaterThan ?? undefined;
    return message;
  },
};

function createBaseDecimalConstraint(): DecimalConstraint {
  return { MinValue: 0, MaxValue: 0, Step: 0 };
}

export const DecimalConstraint = {
  encode(message: DecimalConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.MinValue !== 0) {
      writer.uint32(9).double(message.MinValue);
    }
    if (message.MaxValue !== 0) {
      writer.uint32(17).double(message.MaxValue);
    }
    if (message.Step !== 0) {
      writer.uint32(25).double(message.Step);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DecimalConstraint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecimalConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.MinValue = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.MaxValue = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.Step = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecimalConstraint {
    return {
      MinValue: isSet(object.MinValue) ? globalThis.Number(object.MinValue) : 0,
      MaxValue: isSet(object.MaxValue) ? globalThis.Number(object.MaxValue) : 0,
      Step: isSet(object.Step) ? globalThis.Number(object.Step) : 0,
    };
  },

  toJSON(message: DecimalConstraint): unknown {
    const obj: any = {};
    if (message.MinValue !== 0) {
      obj.MinValue = message.MinValue;
    }
    if (message.MaxValue !== 0) {
      obj.MaxValue = message.MaxValue;
    }
    if (message.Step !== 0) {
      obj.Step = message.Step;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecimalConstraint>, I>>(base?: I): DecimalConstraint {
    return DecimalConstraint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecimalConstraint>, I>>(object: I): DecimalConstraint {
    const message = createBaseDecimalConstraint();
    message.MinValue = object.MinValue ?? 0;
    message.MaxValue = object.MaxValue ?? 0;
    message.Step = object.Step ?? 0;
    return message;
  },
};

function createBaseIntConstraint(): IntConstraint {
  return { MinValue: 0, MaxValue: 0, Step: 0 };
}

export const IntConstraint = {
  encode(message: IntConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.MinValue !== 0) {
      writer.uint32(8).int32(message.MinValue);
    }
    if (message.MaxValue !== 0) {
      writer.uint32(16).int32(message.MaxValue);
    }
    if (message.Step !== 0) {
      writer.uint32(24).int32(message.Step);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IntConstraint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.MinValue = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.MaxValue = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Step = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntConstraint {
    return {
      MinValue: isSet(object.MinValue) ? globalThis.Number(object.MinValue) : 0,
      MaxValue: isSet(object.MaxValue) ? globalThis.Number(object.MaxValue) : 0,
      Step: isSet(object.Step) ? globalThis.Number(object.Step) : 0,
    };
  },

  toJSON(message: IntConstraint): unknown {
    const obj: any = {};
    if (message.MinValue !== 0) {
      obj.MinValue = Math.round(message.MinValue);
    }
    if (message.MaxValue !== 0) {
      obj.MaxValue = Math.round(message.MaxValue);
    }
    if (message.Step !== 0) {
      obj.Step = Math.round(message.Step);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntConstraint>, I>>(base?: I): IntConstraint {
    return IntConstraint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntConstraint>, I>>(object: I): IntConstraint {
    const message = createBaseIntConstraint();
    message.MinValue = object.MinValue ?? 0;
    message.MaxValue = object.MaxValue ?? 0;
    message.Step = object.Step ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
